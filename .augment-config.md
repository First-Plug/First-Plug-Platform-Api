# Augment Agent - ConfiguraciÃ³n del Proyecto FirstPlug

## ğŸ—ï¸ Arquitectura del Sistema

### **PatrÃ³n de Servicios por Capas**

#### **Servicios RaÃ­z (Root Services)**

InteractÃºan directamente con la base de datos, manejan CRUD bÃ¡sico:

- **`ProductsService`**: GestiÃ³n de productos en collections locales
- **`MembersService`**: GestiÃ³n de members y productos embebidos
- **`ShipmentsService`**: GestiÃ³n de shipments y logistics
- **`TenantsService`**: GestiÃ³n de tenants y configuraciÃ³n
- **`WarehousesService`**: GestiÃ³n de warehouses y asignaciones

#### **Servicios Transversales (Cross-cutting Services)**

Coordinan entre servicios raÃ­z, manejan lÃ³gica de negocio compleja:

- **`AssignmentsService`**: Movimiento de productos entre collections + **Multi-office support**
- **`LogisticsService`**: CoordinaciÃ³n de shipments y actualizaciones
- **`GlobalProductSyncService`**: SincronizaciÃ³n a collection global
- **`WarehouseAssignmentService`**: AsignaciÃ³n inteligente de warehouses
- **`ShipmentOfficeCoordinatorService`**: CoordinaciÃ³n entre shipments y oficinas

#### **Servicios Helper**

LÃ³gica de negocio especÃ­fica y reutilizable:

- **`LastAssignedHelper`**: CÃ¡lculo de lastAssigned preservando ubicaciones
- **`SlackService`**: Notificaciones y alertas
- **`HistoryService`**: Tracking de cambios y auditorÃ­a

#### **Servicios de Infraestructura**

- **`SuperAdminService`**: Operaciones cross-tenant, gestiÃ³n global
- **`AuthService`**: AutenticaciÃ³n y autorizaciÃ³n
- **`ConfigService`**: ConfiguraciÃ³n de aplicaciÃ³n
- **`TenantModelRegistry`**: Registry de modelos por tenant (CLAVE)
- **`TenantConnectionService`**: GestiÃ³n de conexiones multi-tenant

#### **ğŸš¨ PATRÃ“N DE COORDINACIÃ“N (REGLA SAGRADA)**

**REGLA FUNDAMENTAL**: Los servicios raÃ­z NUNCA deben depender directamente de otros servicios raÃ­z.

**PROBLEMA COMÃšN**: Inyectar un servicio raÃ­z en otro servicio raÃ­z crea acoplamiento fuerte.

**SOLUCIÃ“N OBLIGATORIA**: Crear servicios transversales coordinadores.

---

### **ğŸ“Š Diagrama de Arquitectura Correcta**

```
SERVICIOS RAÃZ (Root Services)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ProductsService â”‚    â”‚ MembersService  â”‚    â”‚ ShipmentsServiceâ”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ - CRUD productosâ”‚    â”‚ - CRUD members  â”‚    â”‚ - CRUD shipmentsâ”‚
â”‚ - Solo DB ops   â”‚    â”‚ - Solo DB ops   â”‚    â”‚ - Solo DB ops   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TenantsService  â”‚    â”‚WarehousesServiceâ”‚    â”‚ OfficesService  â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ - CRUD tenants  â”‚    â”‚ - CRUD warehouseâ”‚    â”‚ - CRUD offices  â”‚
â”‚ - Solo DB ops   â”‚    â”‚ - Solo DB ops   â”‚    â”‚ - Solo DB ops   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                              â–²
                              â”‚
                    NO DEPENDENCIES ENTRE ELLOS
                              â”‚
                              â–¼

SERVICIOS TRANSVERSALES (Cross-cutting Services)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    COORDINADORES                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ AssignmentsService          â”‚ LogisticsService                  â”‚
â”‚ - Coordina Products+Members â”‚ - Coordina Shipments+Products     â”‚
â”‚                             â”‚                                   â”‚
â”‚ GlobalProductSyncService    â”‚ ShipmentOfficeCoordinatorService  â”‚
â”‚ - Coordina sync global      â”‚ - Coordina Shipments+Offices      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### **âœ… PATRONES CORRECTOS**

#### **1. Coordinador Simple**

```typescript
// âœ… CORRECTO: Servicio transversal coordina entre servicios raÃ­z
@Injectable()
export class ShipmentOfficeCoordinatorService {
  constructor(private readonly officesService: OfficesService) {}

  async handleShipmentStatusChange(
    originOfficeId: Types.ObjectId | null,
    destinationOfficeId: Types.ObjectId | null,
    oldStatus: string,
    newStatus: string,
    tenantName: string,
  ): Promise<void> {
    // LÃ³gica de coordinaciÃ³n
    await this.officesService.updateActiveShipmentsFlagsForShipment(
      originOfficeId,
      destinationOfficeId,
      tenantName,
    );
  }
}

// âœ… CORRECTO: Servicio raÃ­z usa coordinador
@Injectable()
export class ShipmentsService {
  constructor(private readonly coordinator: ShipmentOfficeCoordinatorService) {}

  async updateShipment() {
    // ... lÃ³gica de shipment

    // Delegar coordinaciÃ³n al servicio transversal
    await this.coordinator.handleShipmentStatusChange(
      originOfficeId,
      destinationOfficeId,
      oldStatus,
      newStatus,
      tenantName,
    );
  }
}
```

#### **2. Coordinador Complejo (MÃºltiples Servicios)**

```typescript
// âœ… CORRECTO: Coordinador que maneja mÃºltiples servicios raÃ­z
@Injectable()
export class AssignmentsService {
  constructor(
    private readonly productsService: ProductsService,
    private readonly membersService: MembersService,
    private readonly globalProductSyncService: GlobalProductSyncService,
  ) {}

  async moveProductFromMemberToWarehouse() {
    // Coordina entre mÃºltiples servicios raÃ­z
    const product = await this.productsService.create();
    await this.membersService.removeProduct();
    await this.globalProductSyncService.sync();
  }
}
```

---

### **âŒ ANTI-PATRONES (NUNCA HACER)**

#### **1. Dependencia Directa Entre Servicios RaÃ­z**

```typescript
// âŒ MAL: Servicio raÃ­z dependiendo de otro servicio raÃ­z
@Injectable()
export class ShipmentsService {
  constructor(
    private readonly officesService: OfficesService, // âŒ ACOPLAMIENTO
  ) {}

  async updateShipment() {
    // âŒ Llamada directa entre servicios raÃ­z
    await this.officesService.updateFlags();
  }
}
```

#### **2. LÃ³gica de CoordinaciÃ³n en Servicio RaÃ­z**

```typescript
// âŒ MAL: LÃ³gica de coordinaciÃ³n mezclada con CRUD
@Injectable()
export class ProductsService {
  constructor(
    private readonly membersService: MembersService, // âŒ ACOPLAMIENTO
    private readonly shipmentsService: ShipmentsService, // âŒ ACOPLAMIENTO
  ) {}

  async updateProduct() {
    // âŒ Responsabilidad mezclada
    await this.save(); // CRUD (correcto)
    await this.membersService.updateFlags(); // âŒ CoordinaciÃ³n (incorrecto)
    await this.shipmentsService.updateStatus(); // âŒ CoordinaciÃ³n (incorrecto)
  }
}
```

---

### **ğŸ”§ CÃ“MO REFACTORIZAR ACOPLAMIENTO**

#### **Paso 1: Identificar el Problema**

```typescript
// ğŸš¨ DETECTAR: Â¿Hay servicios raÃ­z inyectados en otros servicios raÃ­z?
class ServiceA {
  constructor(private serviceB: ServiceB) {} // ğŸš¨ PROBLEMA
}
```

#### **Paso 2: Crear Coordinador**

```typescript
// âœ… CREAR: Servicio transversal coordinador
@Injectable()
export class ServiceABCoordinatorService {
  constructor(
    private readonly serviceA: ServiceA,
    private readonly serviceB: ServiceB,
  ) {}

  async coordinateOperation() {
    await this.serviceA.doSomething();
    await this.serviceB.doSomethingElse();
  }
}
```

#### **Paso 3: Refactorizar Dependencias**

```typescript
// âœ… REFACTORIZAR: Usar coordinador en lugar de dependencia directa
class ServiceA {
  constructor(
    private readonly coordinator: ServiceABCoordinatorService, // âœ… CORRECTO
  ) {}

  async operation() {
    await this.coordinator.coordinateOperation();
  }
}
```

#### **Paso 4: Actualizar MÃ³dulos**

```typescript
// âœ… AGREGAR: Coordinador a mÃ³dulos relevantes
@Module({
  providers: [
    ServiceA,
    ServiceB,
    ServiceABCoordinatorService, // âœ… AGREGAR
  ],
})
export class SomeModule {}
```

---

### **ğŸ“‹ CHECKLIST DE VALIDACIÃ“N**

**Antes de crear/modificar servicios:**

- [ ] **Â¿Es un servicio raÃ­z?** â†’ Solo debe hacer CRUD de su entidad
- [ ] **Â¿Necesita otro servicio raÃ­z?** â†’ Crear coordinador transversal
- [ ] **Â¿Es lÃ³gica de coordinaciÃ³n?** â†’ Debe ir en servicio transversal
- [ ] **Â¿Hay dependencias circulares?** â†’ Usar coordinadores para romperlas

**Al revisar cÃ³digo existente:**

- [ ] **Â¿Servicios raÃ­z inyectan otros servicios raÃ­z?** â†’ Refactorizar con coordinador
- [ ] **Â¿LÃ³gica de negocio compleja en servicios raÃ­z?** â†’ Mover a transversal
- [ ] **Â¿MÃºltiples responsabilidades en un servicio?** â†’ Separar en coordinadores

---

### **ğŸ¯ EJEMPLOS REALES DEL PROYECTO**

#### **âœ… CORRECTO: ShipmentOfficeCoordinatorService**

```
ShipmentsService â†’ ShipmentOfficeCoordinatorService â†’ OfficesService
LogisticsService â†’ ShipmentOfficeCoordinatorService â†’ OfficesService
```

#### **âœ… CORRECTO: AssignmentsService**

```
Controller â†’ AssignmentsService â†’ ProductsService + MembersService + GlobalSync
```

#### **âœ… CORRECTO: LogisticsService**

```
Controller â†’ LogisticsService â†’ ShipmentsService + ProductsService + MembersService
```

#### **âŒ INCORRECTO (Ejemplo de lo que NO hacer)**

```
ShipmentsService â†’ OfficesService (ACOPLAMIENTO DIRECTO)
ProductsService â†’ MembersService (ACOPLAMIENTO DIRECTO)
```

#### **Servicios Comunes**

- **`CommonService`**: Utilidades compartidas
- **`ValidationService`**: Validaciones reutilizables
- **`InfraService`**: Servicios de infraestructura base

---

## ğŸ¢ Multi-Tenant Architecture

### **Estructura de Base de Datos**

- **Tenant Database**: `tenant_{tenantName}` (ej: `tenant_mechi_test`)
  - Collections: `products`, `members`, `shipments`, `offices`, `teams`, `historial`, `shipmentsMetadata`
- **Global Database**: `firstPlug`
  - Collections: `tenants`, `users`, `global_products`, `warehouses`

### **Roles y Permisos**

- **SuperAdmin**: Acceso a todos los tenants, puede crear/modificar cualquier dato
- **Tenant User**: Solo acceso a su tenant especÃ­fico
- **admin**: Solo acceso a su tenant especÃ­fico

### **Tenant Resolution**

```typescript
// Siempre resolver tenant por tenantName
const connection = await this.connectionService.getTenantConnection(tenantName);
const ProductModel = connection.model('Product', ProductSchema);
```

---

## ğŸ“¦ Ubicaciones de Productos

### **Ubicaciones VÃ¡lidas**

- **`"Employee"`**: Producto asignado a un member (en `members` collection)
- **`"FP warehouse"`**: Producto en warehouse de FirstPlug (en `products` collection)
- **`"Our office"`**: Producto en oficina del tenant (en `products` collection)

### **Collections por UbicaciÃ³n**

- **Employee** â†’ `members.products[]` (embebido)
- **FP warehouse** â†’ `products` collection + `fpWarehouse` data
- **Our office** â†’ `products` collection + `office` data

### **Multi-Office Support (CORE)**

#### **Estructura de Datos de Oficina**

```typescript
// Estructura del objeto office en productos
office: {
  officeId: ObjectId,           // ID de la oficina
  officeCountryCode: string,    // CÃ³digo de paÃ­s de la oficina
  officeName: string,           // Nombre de la oficina
  assignedAt: Date,            // Fecha de asignaciÃ³n
  isDefault: boolean           // Si es la oficina por defecto
}
```

#### **Reglas de AsignaciÃ³n de Oficina**

- âœ… **`officeId` requerido** cuando `location = "Our office"` en endpoints de usuarios
- âœ… **Oficina default automÃ¡tica** si no se especifica `officeId` para `location = "Our office"`
- âœ… **ValidaciÃ³n de existencia** de oficina antes de asignar
- âœ… **ConstrucciÃ³n automÃ¡tica** del objeto `office` completo usando `buildOfficeObject()`

#### **GestiÃ³n AutomÃ¡tica de Oficina Default (NUEVO)**

- âœ… **Primera oficina** creada se convierte automÃ¡ticamente en default
- âœ… **EliminaciÃ³n de default** asigna automÃ¡ticamente nueva oficina default
- âœ… **Solo una oficina default** por tenant en todo momento
- âœ… **ValidaciÃ³n automÃ¡tica** de integridad de oficinas default

```typescript
// âœ… CORRECTO: GestiÃ³n automÃ¡tica en OfficesService
async ensureDefaultOffice(tenantName: string): Promise<void> {
  // LÃ³gica automÃ¡tica para mantener siempre una oficina default
}
```

#### **Reglas de ImplementaciÃ³n (CRÃTICAS)**

- âœ… **Solo cuando `location = "Our office"`** se debe incluir objeto `office`
- âœ… **Coexistencia obligatoria**: Si maneja `fpWarehouse` â†’ debe manejar `office`
- âœ… **Seguir patrÃ³n `fpWarehouse`** exactamente como referencia
- âœ… **Persistencia obligatoria** en movimientos con `fp_shipment`
- âœ… **Preservar datos existentes** en sincronizaciÃ³n global
- âŒ **NUNCA** agregar `office` a mÃ©todos que NO manejan `fpWarehouse`
- âŒ **NUNCA** hardcodear datos de oficina

#### **Endpoints que Soportan `officeId`**

| Endpoint                          | DTO                     | Soporte Multi-Office                        |
| --------------------------------- | ----------------------- | ------------------------------------------- |
| `POST /products`                  | `CreateProductDto`      | âœ… Individual                               |
| `POST /products/bulkcreate`       | `CreateProductArrayDto` | âœ… **Bulk con diferentes oficinas**         |
| `PATCH /products/:id`             | `UpdateProductDto`      | âœ… Individual                               |
| `PATCH /products/reassign/:id`    | `UpdateProductDto`      | âœ… Individual                               |
| `POST /assignments/bulk-reassign` | `BulkReassignDto`       | âœ… **Bulk con diferentes oficinas**         |
| `POST /assignments/offboard`      | `OffboardMemberDto`     | âœ… **Offboarding con oficinas especÃ­ficas** |

#### **Movimientos Entre Oficinas (NUEVO)**

- âœ… **Oficina A â†’ Oficina B** dentro de `location = "Our office"`
- âœ… **DetecciÃ³n automÃ¡tica** de cambios de `officeId` aunque `location` sea igual
- âœ… **CreaciÃ³n de shipments** para movimientos entre oficinas
- âœ… **PreservaciÃ³n de datos** de oficina origen en shipment

```typescript
// âœ… CORRECTO: DetecciÃ³n de cambio de oficina
const hasOfficeChange =
  updateDto.location === 'Our office' &&
  product.location === 'Our office' &&
  updateDto.officeId &&
  updateDto.officeId !== product.office?.officeId?.toString();
```

#### **ImplementaciÃ³n Obligatoria**

```typescript
// âœ… CORRECTO: Usar buildOfficeObject para construir datos completos
const officeData = await this.assignmentsService.buildOfficeObject(
  officeId,
  tenantName,
);

// âœ… CORRECTO: Aplicar a producto
const productData = {
  ...baseProduct,
  ...officeData, // Incluye objeto office completo
};
```

#### **PatrÃ³n de AsignaciÃ³n con Persistencia (CORE)**

```typescript
// ğŸ¢ OFFICE ASSIGNMENT: Seguir patrÃ³n fpWarehouse
if (updateDto.location === 'Our office' && updateDto.officeId) {
  const officeData = await this.buildOfficeObject(
    updateDto.officeId as string,
    tenantName,
  );

  if (officeData.office) {
    Object.assign(updatedProduct, { office: officeData.office });

    // ğŸ’¾ GUARDAR: Necesario para persistir campos
    await updatedProduct.save({ session });

    // ğŸ”„ SYNC: Forzar sincronizaciÃ³n global
    delete (updatedProduct as any)._alreadySyncedToGlobal;
    await this.syncProductToGlobal(updatedProduct, tenantName, 'products');
  }
}
```

#### **MÃ©todos que Requieren PatrÃ³n de AsignaciÃ³n**

**âœ… MÃ©todos que SÃ implementan el patrÃ³n (porque tambiÃ©n manejan `fpWarehouse`):**

- `handleProductFromMemberCollection` - Con persistencia y sync âœ…
- `assignProduct` - Con construcciÃ³n de office âœ…
- `moveToProductsCollection` - Con handleOfficeAssignment âœ…
- `handleUnknownEmailUpdate` - Con construcciÃ³n bÃ¡sica âœ…

**âŒ MÃ©todos que NO deben implementar el patrÃ³n (porque NO manejan `fpWarehouse`):**

- `updateProductAttributes` - Solo actualiza atributos del array
- `handleProductUnassignment` - Solo desasigna, no maneja objetos
- `handleProductFromProductsCollection` (caso normal) - Solo actualiza campos bÃ¡sicos

**âš ï¸ Regla de Oro: Coexistencia**

- **SI** un mÃ©todo maneja `fpWarehouse` â†’ **DEBE** manejar `office`
- **SI** un mÃ©todo NO maneja `fpWarehouse` â†’ **NO DEBE** manejar `office`
- **Mantener** la coexistencia perfecta entre ambos objetos

#### **âŒ Errores Comunes a Evitar**

1. **âŒ Agregar `office` a `updateProductAttributes`**

   - Este mÃ©todo solo actualiza el array `attributes`
   - NO maneja `fpWarehouse`, por tanto NO debe manejar `office`

2. **âŒ Agregar `office` a `handleProductUnassignment`**

   - Este mÃ©todo solo desasigna productos
   - NO maneja `fpWarehouse`, por tanto NO debe manejar `office`

3. **âŒ Romper la coexistencia**

   - Siempre verificar: "Â¿Este mÃ©todo maneja `fpWarehouse`?"
   - Si NO â†’ NO agregar `office`
   - Si SÃ â†’ SÃ agregar `office`

4. **âŒ Mantener `office` al mover a "Employee"**

   - Cuando un producto se mueve de "Our office" a "Employee", el objeto `office` DEBE eliminarse
   - Solo productos en `location: "Our office"` deben tener objeto `office`
   - Verificar que `handleOfficeAssignment` elimine `office` para locations â‰  "Our office"

5. **âŒ Preservar `office` incorrectamente en sync global**
   - Solo preservar `office` existente si la nueva location sigue siendo "Our office"
   - Si location cambiÃ³ a "Employee" o "FP warehouse", `office` debe ser `null`

---

## ï¿½ Estados de Productos (SAGRADO)

### **Regla Fundamental: Estado = f(Location, Shipment)**

#### **Sin Shipment Activo**

- **Location: `"Employee"`** â†’ Status: `"Delivered"`
- **Location: `"FP warehouse"`** â†’ Status: `"Available"`
- **Location: `"Our office"`** â†’ Status: `"Available"`

#### **Con Shipment Activo (SincronizaciÃ³n Obligatoria)**

| Shipment Status            | Product Status                |
| -------------------------- | ----------------------------- |
| `"On Hold - Missing Data"` | `"In Transit - Missing Data"` |
| `"In Preparation"`         | `"In Transit"`                |
| `"On The Way"`             | `"In Transit"`                |
| `"Received"`               | SegÃºn location final          |
| `"Cancelled"`              | SegÃºn location final          |

### **ImplementaciÃ³n Obligatoria**

```typescript
// SIEMPRE calcular status basado en shipment + location
const status = await this.productsService.determineProductStatus(
  {
    fp_shipment: product.fp_shipment,
    location: product.location,
    activeShipment: product.activeShipment,
  },
  tenantName,
);
```

---

## ï¿½ğŸ”„ Acciones de Movimiento de Productos

### **Acciones VÃ¡lidas**

- **`assign`**: Asignar producto disponible a member
- **`reassign`**: Cambiar asignaciÃ³n de producto (member â†’ warehouse/office, warehouse â†” office)
- **`return`**: Devolver producto de member a warehouse u office
- **`relocate`**: Mover producto desde member a otro member
- **`offboarding`**: Procesar productos de member que se va se pueden enviar a otro member, office o warehouse

### **Movimientos Warehouse â†” Office (NUEVO)**

#### **Funcionalidad Implementada**

- âœ… **FP warehouse â†’ Our office** usando `assign`/`reassign`
- âœ… **Our office â†’ FP warehouse** usando `assign`/`reassign`
- âœ… **Limpieza automÃ¡tica** de objetos de ubicaciÃ³n anterior
- âœ… **PreservaciÃ³n de `lastAssigned`** con formato correcto

#### **ImplementaciÃ³n TÃ©cnica**

```typescript
// ğŸ§¹ MÃ©todo de limpieza automÃ¡tica
private handleLocationObjectCleanup(
  newLocation: string | undefined,
  currentProduct: any,
): { fpWarehouse?: undefined; office?: undefined } {
  // Detecta movimientos y limpia objetos automÃ¡ticamente
  // - Warehouse â†’ Office: limpia fpWarehouse
  // - Office â†’ Warehouse: limpia office
  // - Warehouse/Office â†’ Employee: limpia ambos
}
```

#### **IntegraciÃ³n en MÃ©todos Clave**

- âœ… **`moveToProductsCollection()`** - Member â†’ Warehouse/Office
- âœ… **`moveToMemberCollection()`** - Warehouse/Office â†’ Member
- âœ… **`handleProductFromProductsCollection()`** - Warehouse â†” Office directo
- âŒ **`handleUnknownEmailUpdate()`** - NO aplica (ver secciÃ³n anterior)

#### **Casos de Uso**

```typescript
// âœ… Office â†’ Warehouse
{
  "location": "FP warehouse",
  "actionType": "reassign",
  "assignedEmail": "none",
  "status": "Available"
}

// âœ… Warehouse â†’ Office
{
  "location": "Our office",
  "actionType": "reassign",
  "assignedEmail": "none",
  "officeId": "office-id", // Opcional, usa default
  "status": "Available"
}
```

#### **PreservaciÃ³n de lastAssigned**

- **Warehouse â†’ Office**: `lastAssigned = "FP warehouse - AR - Warehouse Name"`
- **Office â†’ Warehouse**: `lastAssigned = "Our office - AR - Office Name"`
- **Formato automÃ¡tico** usando `LastAssignedHelper`

### **Requerimientos OBLIGATORIOS**

#### **1. Preservar `lastAssigned`**

```typescript
// SIEMPRE usar LastAssignedHelper para calcular lastAssigned
const calculatedLastAssigned =
  this.lastAssignedHelper.calculateForProductUpdate(
    product,
    newLocation,
    actionType,
  );
```

#### **2. SincronizaciÃ³n Global**

```typescript
// SIEMPRE sincronizar a global collection despuÃ©s de cambios
await this.globalProductSyncService.syncProduct({
  tenantId: tenantName,
  originalProductId: product._id,
  sourceCollection: 'products' | 'members',
  // ... otros campos
});
```

#### **3. Transacciones MongoDB**

```typescript
// SIEMPRE usar transacciones para operaciones crÃ­ticas
const session = await connection.startSession();
session.startTransaction();
try {
  // ... operaciones
  await session.commitTransaction();
} catch (error) {
  await session.abortTransaction();
  throw error;
} finally {
  session.endSession();
}
```

#### **4. Validaciones de Estado**

- **activeShipment**: No permitir cambios si producto tiene shipment activo
- **Warehouse assignment**: Asignar warehouse automÃ¡ticamente para `location: "FP warehouse"`
- **Member validation**: Verificar que member existe antes de asignar

#### **5. Evitar Duplicados**

- **Una sola sincronizaciÃ³n por flujo**: Usar flag `_alreadySyncedToGlobal`
- **Consistent IDs**: Usar mismo `_id` para `originalProductId` en global collection

---

## ğŸ“§ Productos con Emails Desconocidos (CRÃTICO)

### **Contexto: `handleUnknownEmailUpdate()`**

Este mÃ©todo maneja un caso especial muy importante que **NO debe confundirse** con movimientos warehouseâ†”office.

#### **Â¿QuÃ© son productos con emails desconocidos?**

- **Origen**: Productos subidos via CSV con `assignedEmail` que **no hace match** con ningÃºn member en la colecciÃ³n `members`
- **UbicaciÃ³n temporal**: Se almacenan en `products` collection porque **no hay member registrado** con ese email
- **Realidad conceptual**: Son productos de **"members fantasma"** - el email representa a un empleado real, pero ese empleado no estÃ¡ registrado en el sistema
- **UbicaciÃ³n lÃ³gica**: Conceptualmente son `"Employee"` (asignados a un member), pero temporalmente estÃ¡n en `products`

#### **Flujos posibles:**

1. **Se registra el member** â†’ El producto se mueve automÃ¡ticamente a `members.products[]`
2. **Se reasigna el producto** â†’ Desde "member fantasma" hacia warehouse, office, o member real

#### **âš ï¸ REGLA CRÃTICA: NO es movimiento warehouseâ†”office**

```typescript
// âŒ INCORRECTO: Agregar cleanup warehouseâ†”office aquÃ­
public async handleUnknownEmailUpdate() {
  // ...
  const cleanupFields = this.handleLocationObjectCleanup(); // âŒ NO APLICA
}

// âœ… CORRECTO: Solo manejar asignaciones normales
public async handleUnknownEmailUpdate() {
  // Warehouse assignment si se mueve a "FP warehouse"
  // Office assignment si se mueve a "Our office"
  // NO cleanup porque origen NUNCA es warehouse/office
}
```

#### **Â¿Por quÃ© NO aplica cleanup warehouseâ†”office?**

- **Origen siempre es "Employee"** (member fantasma)
- **Destino puede ser warehouse/office/employee**, pero **origen nunca es warehouse/office**
- **No hay objetos `fpWarehouse` o `office`** que limpiar porque el producto viene de un "member fantasma"

#### **Casos de uso reales:**

```typescript
// âœ… VÃLIDO: Member fantasma â†’ FP warehouse
{
  assignedEmail: "empleado.no.registrado@empresa.com", // No existe en members
  location: "FP warehouse",
  actionType: "reassign"
}

// âœ… VÃLIDO: Member fantasma â†’ Our office
{
  assignedEmail: "empleado.no.registrado@empresa.com", // No existe en members
  location: "Our office",
  actionType: "reassign",
  officeId: "office-id"
}

// âœ… VÃLIDO: Member fantasma â†’ Member real
{
  assignedEmail: "empleado.registrado@empresa.com", // Existe en members
  location: "Employee",
  actionType: "reassign"
}
```

#### **ğŸš¨ Regla de Oro para Modificaciones**

**ANTES** de modificar `handleUnknownEmailUpdate()`:

1. **Preguntarse**: Â¿El producto viene de warehouse o office?
2. **Respuesta**: **NO** - siempre viene de "member fantasma"
3. **ConclusiÃ³n**: **NO** agregar cleanup warehouseâ†”office
4. **AcciÃ³n**: Solo manejar asignaciones hacia destino final

#### **MÃ©todos donde SÃ aplica cleanup warehouseâ†”office:**

- âœ… `moveToProductsCollection()` - Member real â†’ Warehouse/Office
- âœ… `moveToMemberCollection()` - Warehouse/Office â†’ Member real
- âœ… `handleProductFromProductsCollection()` - Warehouse â†” Office directo

#### **MÃ©todos donde NO aplica cleanup:**

- âŒ `handleUnknownEmailUpdate()` - Member fantasma â†’ Cualquier destino
- âŒ `updateProductAttributes()` - Solo actualiza atributos
- âŒ `handleProductUnassignment()` - Solo desasigna

---

## ğŸ“¦ InyecciÃ³n de Modelos (PATRÃ“N CORE - CRÃTICO)

### **âœ… CORRECTO: Inyectar el modelo en el constructor**

Todos los servicios que acceden a datos **DEBEN inyectar el modelo** en el constructor:

```typescript
@Injectable()
export class QuotesService {
  constructor(
    @Inject('QUOTE_MODEL') private quoteRepository: Model<QuoteDocument>,
    private readonly tenantConnectionService: TenantConnectionService,
  ) {}

  async findAll(userEmail: string): Promise<Quote[]> {
    // âœ… Usar this.quoteRepository directamente
    return this.quoteRepository
      .find({ userEmail, isDeleted: false })
      .sort({ createdAt: -1 })
      .exec();
  }
}
```

### **âŒ INCORRECTO: Obtener el modelo de la conexiÃ³n en cada mÃ©todo**

```typescript
// âŒ NO HACER ESTO - PatrÃ³n antiguo
async findAll(tenantName: string, userEmail: string) {
  const connection = await this.tenantConnectionService.getTenantConnection(tenantName);
  const QuoteModel = connection.model('Quote', QuoteSchema);
  // ... resto del cÃ³digo
}
```

### **Â¿Por quÃ© es CRÃTICO?**

1. **Consistencia**: El modelo inyectado se resuelve automÃ¡ticamente en el contexto del tenant actual
2. **Middleware**: El middleware de tenant ya ha resuelto la conexiÃ³n correcta
3. **Limpieza**: Menos cÃ³digo repetitivo en cada mÃ©todo
4. **Performance**: Evita obtener la conexiÃ³n mÃºltiples veces
5. **Mantenibilidad**: CÃ³digo mÃ¡s limpio y fÃ¡cil de mantener

### **Pasos para Implementar**

#### **1. Registrar el modelo en `tenant-models-provider.ts`**

```typescript
export const tenantModels = {
  quoteModel: {
    provide: 'QUOTE_MODEL',
    useFactory: async (tenantConnection: Connection) => {
      return tenantConnection.model(Quote.name, QuoteSchema);
    },
    inject: ['TENANT_CONNECTION'],
  },
};
```

#### **2. Importar en el mÃ³dulo del servicio**

```typescript
@Module({
  providers: [
    QuotesService,
    tenantModels.quoteModel, // âœ… Registrar el modelo
  ],
})
export class QuotesModule {}
```

#### **3. Inyectar en el servicio**

```typescript
@Injectable()
export class QuotesService {
  constructor(
    @Inject('QUOTE_MODEL') private quoteRepository: Model<QuoteDocument>,
    private readonly tenantConnectionService: TenantConnectionService,
  ) {}
}
```

#### **4. Usar en mÃ©todos**

```typescript
// âœ… Usar this.quoteRepository directamente
async findAll(userEmail: string): Promise<Quote[]> {
  return this.quoteRepository
    .find({ userEmail, isDeleted: false })
    .sort({ createdAt: -1 })
    .exec();
}
```

### **CuÃ¡ndo usar `TenantConnectionService`**

Solo usar `getTenantConnection()` cuando necesites:

1. **Transacciones**: `connection.startSession()`
2. **Operaciones atÃ³micas**: MÃºltiples modelos en una transacciÃ³n
3. **Acceso directo a colecciones**: `connection.db.collection()`
4. **Modelos dinÃ¡micos**: Crear modelos sobre la marcha

```typescript
// âœ… Correcto: Usar para transacciones
async create(dto: CreateQuoteDto, tenantName: string) {
  const connection = await this.tenantConnectionService.getTenantConnection(tenantName);
  const session = await connection.startSession();
  session.startTransaction();

  try {
    // ... operaciones usando this.quoteRepository
    await session.commitTransaction();
  } finally {
    session.endSession();
  }
}
```

### **Checklist para nuevos servicios**

- [ ] Â¿Necesita acceso a datos? â†’ Inyectar modelo en constructor
- [ ] Â¿El modelo estÃ¡ registrado en `tenant-models-provider.ts`?
- [ ] Â¿El mÃ³dulo importa el modelo?
- [ ] Â¿Se usa `TenantConnectionService` solo para transacciones?
- [ ] Â¿Se removieron parÃ¡metros `tenantName` no utilizados?

---

## ğŸ› ï¸ Reglas de Desarrollo

### **GestiÃ³n de Dependencias**

- âœ… **SIEMPRE** usar package managers: `npm install`, `yarn add`, etc.
- âŒ **NUNCA** editar manualmente: `package.json`, `requirements.txt`, etc.

### **EdiciÃ³n de Archivos**

- âœ… **Archivos existentes**: Usar `str-replace-editor`
- âœ… **Archivos nuevos**: Usar `save-file`
- âŒ **NUNCA** sobrescribir archivos existentes con `save-file`

### **Validaciones**

- âœ… **Nuevos endpoints**: Usar Zod schemas
- âœ… **DTOs**: Convertir de class-validator a Zod cuando sea necesario
- âœ… **ValidaciÃ³n condicional**: `name` requerido solo para category "Merchandising"
- âœ… **Serial Number**: Opcional pero Ãºnico por tenant (cuando se proporciona)
- âœ… **Bulk operations**: Validar duplicados solo en serial numbers no-null

### **Validaciones de Seguridad (CRÃTICAS)**

#### **1. RestricciÃ³n de "FP warehouse" para usuarios regulares**

- âœ… **Backend validation**: Usuarios regulares NO pueden crear productos inicialmente en "FP warehouse"
- âœ… **Permitir movimientos**: Usuarios SÃ pueden mover productos a "FP warehouse" via return/reassign/offboarding
- âœ… **SuperAdmin exception**: SuperAdmin SÃ puede crear productos en "FP warehouse"
- âœ… **ActionType detection**: Usar presencia de `actionType` para distinguir creaciÃ³n vs movimiento

```typescript
// âœ… CORRECTO: ValidaciÃ³n en Zod schema
.refine(
  (data) => {
    // Solo bloquear si es creaciÃ³n inicial (sin actionType) y usuario regular
    return !(data.location === 'FP warehouse' && !data.actionType);
  },
  { message: 'Regular users cannot create products in FP warehouse' }
)

// âœ… CORRECTO: ValidaciÃ³n en service
if (createDto.location === 'FP warehouse' && !isSuperAdmin) {
  throw new BadRequestException('Regular users cannot create products in FP warehouse');
}
```

#### **2. ValidaciÃ³n de oficinas con shipments activos**

- âœ… **Bloqueo de ediciÃ³n**: Oficinas con shipments "On The Way" no pueden editarse
- âœ… **Frontend support**: Endpoint GET /offices incluye `hasOnTheWayShipments` para deshabilitar UI
- âœ… **Mensaje claro**: Error descriptivo cuando se intenta editar oficina bloqueada

```typescript
// âœ… CORRECTO: Datos enviados al frontend
{
  "_id": "...",
  "name": "Oficina Principal",
  "hasOnTheWayShipments": true,  // â† Frontend usa esto para deshabilitar ediciÃ³n
  "hasActiveShipments": true,
  "hasAssignedProducts": true
}
```

### **Logging y Debugging**

- âœ… **Logs estructurados**: Incluir contexto (tenantName, productId, etc.)
- âœ… **Prefijos claros**: `[ServiceName]`, `ğŸ”„`, `âœ…`, `âŒ`
- âœ… **Debug logs**: Para troubleshooting de bugs complejos
- âœ… **Logs temporales**: Agregar para debugging, remover despuÃ©s de fix
- âœ… **Logs de validaciÃ³n**: Para identificar quÃ© validaciÃ³n especÃ­fica falla

#### **PatrÃ³n de Debugging Efectivo**

```typescript
// âœ… CORRECTO: Logs temporales para debugging
console.log('ğŸ” [METHOD_NAME] Datos antes de operaciÃ³n:', {
  productId: product._id,
  location: product.location,
  hasOffice: !!product.office,
  officeData: product.office,
});

// DespuÃ©s de identificar y corregir el problema:
// âŒ REMOVER: Los logs temporales de debugging
```

#### **Logs de ValidaciÃ³n para 400 Errors**

```typescript
// âœ… CORRECTO: Logs para identificar validaciones que fallan

const hasOnTheWayShipments = await this.hasOnTheWayShipments(id, tenantName);

if (hasOnTheWayShipments) {
  throw new BadRequestException('...');
}
```

---

## ğŸ› Bugs Conocidos y Soluciones

### **1. Acoplamiento de Servicios (CRÃTICO)**

**Causa**: Inyectar servicios raÃ­z en otros servicios raÃ­z
**SÃ­ntomas**:

- Dependencias circulares
- CÃ³digo difÃ­cil de testear
- ViolaciÃ³n de responsabilidad Ãºnica
  **SoluciÃ³n**: Crear servicio coordinador transversal
  **Ejemplo**: `ShipmentOfficeCoordinatorService` para `ShipmentsService` â†” `OfficesService`

### **2. Duplicados en Global Collection**

**Causa**: MÃºltiples sincronizaciones del mismo producto
**SoluciÃ³n**: Flag `_alreadySyncedToGlobal` + skip resync para reassign/return

### **3. lastAssigned VacÃ­o**

**Causa**: No preservar ubicaciÃ³n anterior al mover productos
**SoluciÃ³n**: Usar `LastAssignedHelper.calculateForProductUpdate()`

### **4. originalProductId null**

**Causa**: Sincronizar antes de que el producto tenga `_id`
**SoluciÃ³n**: Sincronizar DESPUÃ‰S de `member.save()`

### **5. CSV con FP warehouse**

**Causa**: Templates viejos permiten ubicaciÃ³n no vÃ¡lida
**SoluciÃ³n**: ValidaciÃ³n Zod que rechaza arrays con `location: "FP warehouse"`

### **6. Eventos Innecesarios**

**Causa**: Usar eventos complejos para coordinaciÃ³n simple
**SÃ­ntomas**:

- Listeners complejos
- CÃ³digo difÃ­cil de seguir
- Debugging complicado
  **SoluciÃ³n**: Llamadas directas a travÃ©s de coordinadores

### **7. SerialNumber duplicado con strings vacÃ­as**

**Causa**: SuperAdmin methods no normalizaban `serialNumber`, guardando `""` en lugar de `undefined`
**SÃ­ntomas**: Error `E11000 duplicate key error` al crear productos con `serialNumber: ""`
**SoluciÃ³n**: NormalizaciÃ³n obligatoria `serialNumber?.trim() || undefined` en todos los mÃ©todos

```typescript
// âœ… CORRECTO: NormalizaciÃ³n en todos los mÃ©todos
const normalizedSerialNumber = serialNumber?.trim() || undefined;

// âœ… APLICAR EN: create, bulkCreate, createProductForTenant, bulkCreateProductsForTenant
```

### **8. Objeto office no eliminado al asignar a Employee**

**Causa**: `handleOfficeAssignment` preservaba `office` para cualquier location con office existente
**SÃ­ntomas**: Productos en "Employee" mantenÃ­an objeto `office` de ubicaciÃ³n anterior
**SoluciÃ³n**: Solo preservar `office` si `location === 'Our office'`

```typescript
// âœ… CORRECTO: EliminaciÃ³n condicional de office
if (location === 'Our office' && currentOffice) {
  return { office: currentOffice };
}
// Para cualquier otra location, no incluir office
return {};
```

### **9. Shipments no creados para movimientos entre oficinas**

**Causa**: Solo se detectaban cambios de `location`, no cambios de `officeId` dentro de la misma location
**SÃ­ntomas**: Productos movidos entre oficinas no generaban shipments aunque `fp_shipment: true`
**SoluciÃ³n**: Detectar cambios de oficina ademÃ¡s de cambios de location

```typescript
// âœ… CORRECTO: DetecciÃ³n de cambios de oficina
const hasLocationChange =
  updateDto.location && updateDto.location !== product.location;
const hasOfficeChange =
  updateDto.location === 'Our office' &&
  product.location === 'Our office' &&
  updateDto.officeId &&
  updateDto.officeId !== product.office?.officeId?.toString();

if (hasLocationChange || hasOfficeChange) {
  // Procesar movimiento y crear shipment si es necesario
}
```

### **10. Offboarding con oficinas especÃ­ficas**

**Causa**: El offboarding no soportaba asignaciÃ³n a oficinas especÃ­ficas, solo oficina genÃ©rica
**SÃ­ntomas**: Productos offbordeados siempre iban a oficina default, no a oficina seleccionada
**SoluciÃ³n**: Agregar soporte para `officeId` en datos de offboarding

```typescript
// âœ… CORRECTO: Soporte de officeId en offboarding
data: Array<{
  product: any;
  relocation: 'New employee' | 'FP warehouse' | 'My office';
  newMember?: { email: string; fullName: string };
  desirableDate: string | { origin?: string; destination?: string };
  fp_shipment?: boolean;
  officeId?: string; // â† NUEVO: Oficina especÃ­fica
}>;
```

### **11. Oficinas duplicadas por nombre sin considerar paÃ­s (RESUELTO)**

**Causa**: ValidaciÃ³n de unicidad de oficinas solo verificaba `name`, no la combinaciÃ³n `name + country`
**SÃ­ntomas**: No se podÃ­a crear "Oficina Brasil" en BR si ya existÃ­a "Oficina Brasil" en AR
**SoluciÃ³n**: Actualizar validaciÃ³n en 3 mÃ©todos de `OfficesService`:

```typescript
// âœ… CORRECTO: ValidaciÃ³n de nombre + paÃ­s
const existingOfficeWithNameAndCountry = await OfficeModel.findOne({
  name: { $regex: new RegExp(`^${createOfficeDto.name}$`, 'i') },
  country: createOfficeDto.country, // â† AGREGAR: Validar paÃ­s tambiÃ©n
  isDeleted: false,
});

if (existingOfficeWithNameAndCountry) {
  throw new BadRequestException(
    `Ya existe una oficina con el nombre "${createOfficeDto.name}" en el paÃ­s "${createOfficeDto.country}" en este tenant`,
  );
}
```

**MÃ©todos actualizados:**

- âœ… `createOffice()` - Valida `name + country`
- âœ… `updateDefaultOffice()` - Valida `name + country`
- âœ… `updateOffice()` - Valida `name + country`

### **12. Productos en bulkCreate sin sincronizaciÃ³n a colecciÃ³n global (RESUELTO)**

**Causa**: `ProductsService.bulkCreate()` creaba productos pero no sincronizaba `fpWarehouse` y `memberData` a la colecciÃ³n global
**SÃ­ntomas**:

- Productos con `location: "FP warehouse"` tenÃ­an `fpWarehouse: null` en global collection
- Productos con `location: "Employee"` tenÃ­an `memberData: null` en global collection

**SoluciÃ³n**: Poblar `productWarehouseMap` despuÃ©s de generar IDs:

```typescript
// âœ… CORRECTO: Poblar productWarehouseMap para sincronizaciÃ³n
productsWithIds.forEach((product) => {
  if (product.location === 'FP warehouse' && product.fpWarehouse) {
    const productIdStr = product._id.toString();
    productWarehouseMap.set(productIdStr, {
      warehouseId: product.fpWarehouse.warehouseId,
      warehouseCountryCode: product.fpWarehouse.warehouseCountryCode,
      warehouseName: product.fpWarehouse.warehouseName,
      assignedAt: product.fpWarehouse.assignedAt,
      status: product.fpWarehouse.status,
    });
  }
});
```

**Resultado**: Ahora la sincronizaciÃ³n en lÃ­neas 693-753 de `bulkCreate()` incluye correctamente:

- âœ… `memberData` para productos asignados a members
- âœ… `fpWarehouse` para productos en FP warehouse
- âœ… `office` para productos en oficinas

---

## ï¿½ CSV Upload - Productos y Members

### **CSV de Productos (bulkCreate-csv)**

#### **Validaciones Especiales para CSV**

```typescript
// âœ… CORRECTO: ValidaciÃ³n condicional por location
if (assignedEmail) {
  // Location DEBE ser "Employee"
  // country y officeName NO deben estar presentes
} else if (location === 'FP warehouse') {
  // country REQUERIDO
  // officeName NO debe estar presente
  // Warehouse asignado automÃ¡ticamente
} else if (location === 'Our office') {
  // country REQUERIDO
  // officeName REQUERIDO
  // Oficina creada o reutilizada automÃ¡ticamente
}
```

#### **ConversiÃ³n de CÃ³digos de PaÃ­s**

- âœ… **Acepta nombres completos**: "Brazil", "Argentina", "Barbados"
- âœ… **Acepta cÃ³digos ISO**: "BR", "AR", "BB"
- âœ… **Convierte automÃ¡ticamente**: "Brazil" â†’ "BR"
- âœ… **Usa mapping**: `countryCodes` de `src/shipments/helpers/countryCodes.ts`
- âœ… **BÃºsqueda case-insensitive**: "brazil" = "Brazil" = "BR"

**ImplementaciÃ³n**: `CSVOfficeCoordinatorService.getCountryCode()`

#### **CreaciÃ³n de Oficinas desde CSV**

- âœ… **ValidaciÃ³n**: `name + country` (no solo `name`)
- âœ… **ReutilizaciÃ³n**: Si existe oficina con mismo `name + country`, se reutiliza
- âœ… **CreaciÃ³n**: Si no existe, se crea automÃ¡ticamente
- âœ… **SincronizaciÃ³n**: Oficina se sincroniza a colecciÃ³n global

**ImplementaciÃ³n**: `CSVOfficeCoordinatorService.handleOfficeAssignmentForCSV()`

#### **SincronizaciÃ³n Global desde CSV**

- âœ… **Todos los productos** se sincronizan a `firstPlug.global_products`
- âœ… **Incluye `fpWarehouse`** para productos en "FP warehouse"
- âœ… **Incluye `memberData`** para productos asignados a members
- âœ… **Incluye `office`** para productos en "Our office"

**ImplementaciÃ³n**: `ProductsService.bulkCreate()` lÃ­neas 693-753

### **CSV de Members (bulkCreate)**

#### **Campos Soportados**

| Campo       | Tipo   | Requerido | Notas                      |
| ----------- | ------ | --------- | -------------------------- |
| `firstName` | string | âœ…        | Nombre del member          |
| `lastName`  | string | âœ…        | Apellido del member        |
| `email`     | string | âœ…        | Email Ãºnico por tenant     |
| `position`  | string | âœ…        | Puesto/rol                 |
| `dni`       | string | âŒ        | **NUEVO**: DNI/CI/Passport |
| `phone`     | string | âŒ        | TelÃ©fono                   |
| `city`      | string | âŒ        | Ciudad                     |
| `country`   | string | âŒ        | PaÃ­s (cÃ³digo ISO o nombre) |

#### **Campo DNI (NUEVO)**

- âœ… **Opcional**: No requerido en CSV
- âœ… **Acepta letras y nÃºmeros**: "12345678A", "V-87654321", "123456789"
- âœ… **Ãšnico por tenant**: ValidaciÃ³n de unicidad
- âœ… **Trim automÃ¡tico**: Elimina espacios al inicio/final
- âœ… **Almacenamiento**: Se guarda en `members.dni`

**ImplementaciÃ³n**: `MembersService.create()` y `bulkCreate()`

---

## ğŸ“¦ CSV de Productos - Nuevas Columnas (ACTUALIZADO)

### **Columnas Soportadas en CSV**

| Columna            | Tipo    | Requerido     | Comportamiento                                              |
| ------------------ | ------- | ------------- | ----------------------------------------------------------- |
| `name`             | string  | âŒ Opcional\* | \*Requerido si category es "Merchandising" o "Other"        |
| `category`         | enum    | âœ… SÃ­         | Computer, Monitor, Audio, Peripherals, Merchandising, Other |
| `serialNumber`     | string  | âŒ Opcional   | Ãšnico por tenant, se convierte a minÃºsculas                 |
| `productCondition` | enum    | âŒ Opcional   | Optimal, Defective, Unusable - **Default: Optimal**         |
| `recoverable`      | boolean | âŒ Opcional   | **Default: Usa config del tenant**                          |
| `additionalInfo`   | string  | âŒ Opcional   | InformaciÃ³n adicional del producto                          |
| `price`            | object  | âŒ Opcional   | `{ amount: number, currencyCode: string }`                  |
| `location`         | enum    | âœ… SÃ­         | Employee, Our office, FP warehouse                          |
| `assignedEmail`    | string  | âŒ Opcional   | Email del member (solo si location=Employee)                |
| `country`          | string  | âŒ Opcional\* | \*Requerido si location es "Our office" o "FP warehouse"    |
| `officeName`       | string  | âŒ Opcional\* | \*Requerido si location es "Our office"                     |

### **Cambios Implementados**

#### **1. `productCondition` Ahora es Opcional**

**Antes:**

```typescript
// Siempre sobrescribÃ­a a 'Optimal'
product.productCondition = 'Optimal';
```

**Ahora:**

```typescript
// Respeta el valor del CSV, solo usa 'Optimal' si no viene
if (!productCondition) {
  product.productCondition = 'Optimal';
}
```

**UbicaciÃ³n:** `src/products/products.service.ts` lÃ­nea 540-543

#### **2. ValidaciÃ³n de `name` Extendida**

**Antes:**

```typescript
// Solo requerido para Merchandising
if (data.category === 'Merchandising' && !data.name)
```

**Ahora:**

```typescript
// Requerido para Merchandising Y Other
if ((data.category === 'Merchandising' || data.category === 'Other') && !data.name)
```

**UbicaciÃ³n:** `src/products/validations/create-product.zod.ts` lÃ­nea 569-579

#### **3. Schema Zod Actualizado**

```typescript
productCondition: z.enum(CONDITION).optional(), // ğŸ”§ Opcional en CSV
```

**UbicaciÃ³n:** `src/products/validations/create-product.zod.ts` lÃ­nea 462

### **Comportamiento de Defaults**

| Campo              | Si estÃ¡ vacÃ­o en CSV | Comportamiento                                    |
| ------------------ | -------------------- | ------------------------------------------------- |
| `productCondition` | âœ… VacÃ­o             | Se asigna `'Optimal'`                             |
| `recoverable`      | âœ… VacÃ­o             | Se usa `isRecoverableConfig[category]` del tenant |
| `additionalInfo`   | âœ… VacÃ­o             | Se deja vacÃ­o (opcional)                          |
| `price`            | âœ… VacÃ­o             | Se deja vacÃ­o (opcional)                          |

### **Validaciones Aplicadas**

âœ… **Price + Currency:** Ambos deben estar presentes o ambos vacÃ­os
âœ… **Name:** Requerido para "Merchandising" y "Other"
âœ… **Country:** Requerido para "Our office" y "FP warehouse"
âœ… **OfficeName:** Requerido para "Our office"
âœ… **AssignedEmail:** Solo permitido si location es "Employee"

---

## ğŸš¢ Offboarding - Tracking de Shipments (NUEVO)

### **MÃ©todo `offboardMember()` - Retorno Actualizado**

#### **Cambio Implementado**

**Antes:**

```typescript
Promise<{ message: string }>;
```

**Ahora:**

```typescript
Promise<{
  message: string;
  lastShipmentCreated?: ObjectId;
}>;
```

#### **Comportamiento**

- âœ… **Rastreo automÃ¡tico**: Captura el ID del Ãºltimo shipment creado durante el offboarding
- âœ… **ConsolidaciÃ³n soportada**: Si mÃºltiples productos se consolidan en un shipment, retorna el ID del Ãºltimo
- âœ… **Sin shipments**: Si no se crean shipments, `lastShipmentCreated` es `undefined`
- âœ… **MÃºltiples destinos**: Cuando hay diferentes destinos (member, office, warehouse), retorna el ID del Ãºltimo shipment procesado

#### **ImplementaciÃ³n TÃ©cnica**

```typescript
// En offboardMember() - lÃ­nea 2728
let lastShipmentCreated: ObjectId | null = null; // ğŸš¢ Rastrear Ãºltimo shipment

// En el loop - lÃ­nea 2798-2800
if (result.shipment?._id) {
  lastShipmentCreated = result.shipment._id;
}

// En el return - lÃ­nea 2872-2875
return {
  message: 'Offboarding completed successfully',
  lastShipmentCreated: lastShipmentCreated || undefined,
};
```

#### **Flujo de Ejemplo**

```
Producto 1 â†’ Shipment A (nuevo) â†’ lastShipmentCreated = A._id
Producto 2 â†’ Shipment A (consolidado) â†’ lastShipmentCreated = A._id
Producto 3 â†’ Shipment B (nuevo) â†’ lastShipmentCreated = B._id
Producto 4 â†’ Shipment B (consolidado) â†’ lastShipmentCreated = B._id

Retorno: { message: "...", lastShipmentCreated: B._id }
```

#### **Endpoint Afectado**

- **Ruta**: `POST /members/offboarding/:id`
- **Controller**: `MembersController.offboarding()`
- **Retorno**: AutomÃ¡ticamente incluye `lastShipmentCreated`

---

## ï¿½ğŸ“‹ Checklist para Nuevas Features

### **Antes de Implementar**

- [ ] **ğŸ—ï¸ ARQUITECTURA**: Â¿Respeta el patrÃ³n de servicios por capas?
- [ ] **ğŸš¨ ACOPLAMIENTO**: Â¿Evita dependencias directas entre servicios raÃ­z?
- [ ] **ğŸ”„ COORDINACIÃ“N**: Â¿Necesita coordinador transversal?
- [ ] **ğŸ“¦ MODELOS**: Â¿Necesita inyectar modelos en el servicio? (Ver secciÃ³n "InyecciÃ³n de Modelos")
- [ ] **ModularizaciÃ³n**: Â¿Encaja en carpeta/servicio existente?
- [ ] **Servicios**: Identificar raÃ­z vs transversales involucrados
- [ ] **TenantModelRegistry**: Â¿Requiere nuevos modelos por tenant?
- [ ] **Transacciones**: Â¿Operaciones crÃ­ticas que requieren atomicidad?
- [ ] **SincronizaciÃ³n**: Planificar sync a global collection
- [ ] **Estados**: Considerar impacto en status de productos/shipments
- [ ] **lastAssigned**: Evaluar cambios en ubicaciones

### **Durante ImplementaciÃ³n**

- [ ] **ğŸ—ï¸ SERVICIOS**: Â¿Es servicio raÃ­z o transversal?
- [ ] **ğŸš¨ INYECCIÃ“N**: Â¿Solo inyecta servicios de su capa o inferiores?
- [ ] **ğŸ“¦ MODELOS**: Â¿Inyecta modelos en constructor? (NO obtener de conexiÃ³n en mÃ©todos)
- [ ] **ğŸ”„ COORDINADORES**: Â¿Usa coordinadores para comunicaciÃ³n entre servicios raÃ­z?
- [ ] **Dependencias**: Usar package managers (npm, yarn)
- [ ] **Validaciones**: Implementar schemas Zod
- [ ] **Logs**: Agregar logs estructurados con contexto
- [ ] **Errores**: Manejar excepciones apropiadamente
- [ ] **Estados**: Respetar reglas SAGRADAS de status
- [ ] **Modularidad**: Seguir patrÃ³n de servicios establecido

### **DespuÃ©s de Implementar**

- [ ] **ğŸ—ï¸ ARQUITECTURA**: Â¿Respeta todas las reglas de servicios por capas?
- [ ] **ğŸš¨ ACOPLAMIENTO**: Â¿No hay dependencias directas entre servicios raÃ­z?
- [ ] **ğŸ”„ COORDINACIÃ“N**: Â¿Los coordinadores funcionan correctamente?
- [ ] **Movimientos**: Probar flujos de productos (assign/reassign/return)
- [ ] **SincronizaciÃ³n**: Verificar sync a global collection
- [ ] **Duplicados**: Confirmar que no hay duplicados
- [ ] **Estados**: Validar status correcto segÃºn shipment/location
- [ ] **lastAssigned**: Verificar preservaciÃ³n de ubicaciones
- [ ] **Transacciones**: Confirmar atomicidad de operaciones crÃ­ticas

---

## ğŸ¯ Principios Clave

1. **ModularizaciÃ³n**: Reutilizar servicios existentes antes de crear nuevos
2. **Estados SAGRADOS**: Status de productos SIEMPRE sincronizado con shipments
3. **Consistencia**: Mismo patrÃ³n para operaciones similares
4. **Transaccionalidad**: Operaciones atÃ³micas para integridad de datos
5. **Observabilidad**: Logs claros para debugging
6. **Escalabilidad**: Servicios desacoplados y reutilizables
7. **Confiabilidad**: Validaciones exhaustivas y manejo de errores
8. **TenantModelRegistry**: GestiÃ³n centralizada de modelos multi-tenant

---

## ğŸ“ Attachments en IT Support Services (Release 2 - REFACTORIZADO)

### **Arquitectura de Attachments (REFACTORIZADA - LIMPIA Y REUTILIZABLE)**

#### **Flujo Correcto: Multipart en POST /quotes**

**Endpoint:**

```
POST /quotes
Content-Type: multipart/form-data

Body:
- services: JSON string con servicios (incluyendo IT Support)
- files: array de imÃ¡genes (mÃ¡x 2 por IT Support service)
```

#### **MÃ³dulo Transversal: AttachmentsModule (NUEVO)**

**UbicaciÃ³n:** `src/attachments/`

**Componentes:**

1. **ConfiguraciÃ³n Centralizada**

   - `attachment.config.ts` - Constantes y lÃ­mites
   - ALLOWED_MIMES, MAX_FILE_SIZE, EXPIRATION_DAYS, MAX_FILES_PER_REQUEST

2. **Servicios Reutilizables**

   - `FileValidationService` - ValidaciÃ³n de archivos (individual y mÃºltiples)
   - `AttachmentsGenericService` - LÃ³gica comÃºn (buildAttachment, expiraciÃ³n, etc.)

3. **Helpers EstÃ¡ticos**
   - `SlackAttachmentsHelper` - Formateo de attachments para Slack

#### **Servicios Involucrados**

**Servicios Transversales (Quotes):**

- **`QuotesCoordinatorService`**: Coordina procesamiento de attachments

  - `createQuoteWithCoordination(dto, files)` - procesa attachments + crea quote
  - `processAttachmentsForServices(dto, files)` - valida y sube a Cloudinary
  - `cleanupAttachmentsOnCancel(quoteId)` - borrar de Cloudinary al cancelar
  - âœ… Ahora usa `FileValidationService` y `ATTACHMENT_CONFIG`

- **`AttachmentsCoordinatorService`**: Coordina entre Storage y Attachments
  - `uploadAndPersist(quoteId, file)` - subir y persistir
  - `deleteAttachment(quoteId, publicId)` - borrar
  - `cleanupAttachmentsOnCancel(quoteId)` - limpieza
  - âœ… Ahora usa `FileValidationService` y `ATTACHMENT_CONFIG`

**Servicios Externos:**

- **`StorageService`**: AgnÃ³stico (Cloudinary MVP, S3 futuro)
  - `upload(file, options)` - subir a provider
  - `delete(publicId)` - borrar de provider

#### **Dependencias Correctas (REFACTORIZADAS)**

```typescript
// âœ… CORRECTO: Controller â†’ Coordinador
QuotesController â†’ QuotesCoordinatorService

// âœ… CORRECTO: Coordinador â†’ Servicios transversales
QuotesCoordinatorService â†’ FileValidationService + ATTACHMENT_CONFIG
QuotesCoordinatorService â†’ AttachmentsCoordinatorService

// âœ… CORRECTO: AttachmentsCoordinator â†’ Storage + Attachments
AttachmentsCoordinatorService â†’ StorageService + AttachmentsService
AttachmentsCoordinatorService â†’ FileValidationService + ATTACHMENT_CONFIG

// âœ… CORRECTO: Attachments se guardan DENTRO de Quote
Quote.services[].attachments = [{ provider, publicId, secureUrl, ... }]
```

#### **Validaciones Implementadas (CENTRALIZADAS)**

- âœ… MIME: solo JPEG, PNG, WebP (en `ATTACHMENT_CONFIG`)
- âœ… TamaÃ±o: mÃ¡x 5MB por archivo (en `ATTACHMENT_CONFIG`)
- âœ… Cantidad: mÃ¡x 10 archivos por request (en `ATTACHMENT_CONFIG`)
- âœ… Extensiones: validaciÃ³n adicional (.jpg, .jpeg, .png, .webp)
- âœ… AutomÃ¡tico: attachments se suben a Cloudinary
- âœ… AutomÃ¡tico: metadata se guarda en Quote
- âœ… Reutilizable: mismo cÃ³digo para Shipments, Orders, etc.

#### **Limpieza de Attachments**

```typescript
// Cuando user cancela quote
cancelQuoteWithCoordination()
  â†“
cleanupAttachmentsOnCancel(quoteId)
  â”œâ”€ Obtener todos los attachments
  â”œâ”€ Para cada uno:
  â”‚  â”œâ”€ Borrar de Cloudinary (usando publicId)
  â”‚  â””â”€ Remover de Quote (vaciar array)
  â””â”€ Log de Ã©xito
```

#### **Estructura de Datos**

````typescript
Quote {
  _id: ObjectId,
  requestId: string,
  status: string,
  services: [
    {
      serviceCategory: "IT Support",
      issues: [...],
      description: "...",
      attachments: [
        {
          provider: "cloudinary",
          publicId: "quotes/123/it-support/img1",
          secureUrl: "https://res.cloudinary.com/...",
          mimeType: "image/jpeg",
          bytes: 245000,
          originalName: "damage.jpg",
          createdAt: Date,
          expiresAt: Date
        }
      ]
    }
  ]
}
```
````

#### **Refactoring Completado (NUEVO)**

**Fases Implementadas:**

1. âœ… **Fase 1-2**: ConfiguraciÃ³n centralizada

   - `src/attachments/config/attachment.config.ts`
   - `src/attachments/services/file-validation.service.ts`
   - `src/attachments/attachments.module.ts`

2. âœ… **Fase 3**: Refactorizar AttachmentsCoordinatorService

   - Inyectado `FileValidationService`
   - Inyectado `ATTACHMENT_CONFIG`
   - Removidas constantes hardcodeadas

3. âœ… **Fase 4**: Refactorizar QuotesCoordinatorService

   - Inyectado `FileValidationService`
   - Inyectado `ATTACHMENT_CONFIG`
   - Eliminada duplicaciÃ³n de validaciones

4. âœ… **Fase 5**: Crear AttachmentsGenericService

   - `src/attachments/services/attachments-generic.service.ts`
   - MÃ©todos: buildAttachment, calculateExpirationDate, formatAttachmentForResponse, isExpired, getDaysUntilExpiration

5. âœ… **Fase 6**: Crear SlackAttachmentsHelper
   - `src/attachments/helpers/slack-attachments.helper.ts`
   - MÃ©todos: buildImageBlocks, buildAttachmentInfoBlock, buildAttachmentDetailsBlock, buildCompleteAttachmentBlocks

**Beneficios:**

- âœ… CÃ³digo limpio y modular
- âœ… ConfiguraciÃ³n centralizada (cambiar lÃ­mites en un solo lugar)
- âœ… Validaciones reutilizables (mismo cÃ³digo para todos los mÃ³dulos)
- âœ… Servicios desacoplados (fÃ¡cil de testear)
- âœ… Escalable (listo para Shipments, Orders, etc.)
- âœ… DocumentaciÃ³n: Ver `src/quotes/docs/REFACTORING_COMPLETED.md`

#### **CÃ³mo Usar en Otros MÃ³dulos**

```typescript
// 1. Importar AttachmentsModule
@Module({
  imports: [AttachmentsModule],
})
export class ShipmentsModule {}

// 2. Inyectar servicios
constructor(
  private readonly fileValidation: FileValidationService,
  private readonly attachmentsGeneric: AttachmentsGenericService,
) {}

// 3. Validar archivos
this.fileValidation.validateFiles(files);

// 4. Construir attachment
const attachment = this.attachmentsGeneric.buildAttachment(uploadResult);

// 5. Usar helpers para Slack
const blocks = SlackAttachmentsHelper.buildCompleteAttachmentBlocks(attachments);
```
