# Augment Agent - ConfiguraciÃ³n del Proyecto FirstPlug

## ğŸ—ï¸ Arquitectura del Sistema

### **PatrÃ³n de Servicios por Capas**

#### **Servicios RaÃ­z (Root Services)**

InteractÃºan directamente con la base de datos, manejan CRUD bÃ¡sico:

- **`ProductsService`**: GestiÃ³n de productos en collections locales
- **`MembersService`**: GestiÃ³n de members y productos embebidos
- **`ShipmentsService`**: GestiÃ³n de shipments y logistics
- **`TenantsService`**: GestiÃ³n de tenants y configuraciÃ³n
- **`WarehousesService`**: GestiÃ³n de warehouses y asignaciones

#### **Servicios Transversales (Cross-cutting Services)**

Coordinan entre servicios raÃ­z, manejan lÃ³gica de negocio compleja:

- **`AssignmentsService`**: Movimiento de productos entre collections + **Multi-office support**
- **`LogisticsService`**: CoordinaciÃ³n de shipments y actualizaciones
- **`GlobalProductSyncService`**: SincronizaciÃ³n a collection global
- **`WarehouseAssignmentService`**: AsignaciÃ³n inteligente de warehouses
- **`ShipmentOfficeCoordinatorService`**: CoordinaciÃ³n entre shipments y oficinas

#### **Servicios Helper**

LÃ³gica de negocio especÃ­fica y reutilizable:

- **`LastAssignedHelper`**: CÃ¡lculo de lastAssigned preservando ubicaciones
- **`SlackService`**: Notificaciones y alertas
- **`HistoryService`**: Tracking de cambios y auditorÃ­a

#### **Servicios de Infraestructura**

- **`SuperAdminService`**: Operaciones cross-tenant, gestiÃ³n global
- **`AuthService`**: AutenticaciÃ³n y autorizaciÃ³n
- **`ConfigService`**: ConfiguraciÃ³n de aplicaciÃ³n
- **`TenantModelRegistry`**: Registry de modelos por tenant (CLAVE)
- **`TenantConnectionService`**: GestiÃ³n de conexiones multi-tenant

#### **ğŸš¨ PATRÃ“N DE COORDINACIÃ“N (REGLA SAGRADA)**

**REGLA FUNDAMENTAL**: Los servicios raÃ­z NUNCA deben depender directamente de otros servicios raÃ­z.

**PROBLEMA COMÃšN**: Inyectar un servicio raÃ­z en otro servicio raÃ­z crea acoplamiento fuerte.

**SOLUCIÃ“N OBLIGATORIA**: Crear servicios transversales coordinadores.

---

### **ğŸ“Š Diagrama de Arquitectura Correcta**

```
SERVICIOS RAÃZ (Root Services)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ProductsService â”‚    â”‚ MembersService  â”‚    â”‚ ShipmentsServiceâ”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ - CRUD productosâ”‚    â”‚ - CRUD members  â”‚    â”‚ - CRUD shipmentsâ”‚
â”‚ - Solo DB ops   â”‚    â”‚ - Solo DB ops   â”‚    â”‚ - Solo DB ops   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TenantsService  â”‚    â”‚WarehousesServiceâ”‚    â”‚ OfficesService  â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ - CRUD tenants  â”‚    â”‚ - CRUD warehouseâ”‚    â”‚ - CRUD offices  â”‚
â”‚ - Solo DB ops   â”‚    â”‚ - Solo DB ops   â”‚    â”‚ - Solo DB ops   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                              â–²
                              â”‚
                    NO DEPENDENCIES ENTRE ELLOS
                              â”‚
                              â–¼

SERVICIOS TRANSVERSALES (Cross-cutting Services)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    COORDINADORES                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ AssignmentsService          â”‚ LogisticsService                  â”‚
â”‚ - Coordina Products+Members â”‚ - Coordina Shipments+Products     â”‚
â”‚                             â”‚                                   â”‚
â”‚ GlobalProductSyncService    â”‚ ShipmentOfficeCoordinatorService  â”‚
â”‚ - Coordina sync global      â”‚ - Coordina Shipments+Offices      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### **âœ… PATRONES CORRECTOS**

#### **1. Coordinador Simple**

```typescript
// âœ… CORRECTO: Servicio transversal coordina entre servicios raÃ­z
@Injectable()
export class ShipmentOfficeCoordinatorService {
  constructor(private readonly officesService: OfficesService) {}

  async handleShipmentStatusChange(
    originOfficeId: Types.ObjectId | null,
    destinationOfficeId: Types.ObjectId | null,
    oldStatus: string,
    newStatus: string,
    tenantName: string,
  ): Promise<void> {
    // LÃ³gica de coordinaciÃ³n
    await this.officesService.updateActiveShipmentsFlagsForShipment(
      originOfficeId,
      destinationOfficeId,
      tenantName,
    );
  }
}

// âœ… CORRECTO: Servicio raÃ­z usa coordinador
@Injectable()
export class ShipmentsService {
  constructor(private readonly coordinator: ShipmentOfficeCoordinatorService) {}

  async updateShipment() {
    // ... lÃ³gica de shipment

    // Delegar coordinaciÃ³n al servicio transversal
    await this.coordinator.handleShipmentStatusChange(
      originOfficeId,
      destinationOfficeId,
      oldStatus,
      newStatus,
      tenantName,
    );
  }
}
```

#### **2. Coordinador Complejo (MÃºltiples Servicios)**

```typescript
// âœ… CORRECTO: Coordinador que maneja mÃºltiples servicios raÃ­z
@Injectable()
export class AssignmentsService {
  constructor(
    private readonly productsService: ProductsService,
    private readonly membersService: MembersService,
    private readonly globalProductSyncService: GlobalProductSyncService,
  ) {}

  async moveProductFromMemberToWarehouse() {
    // Coordina entre mÃºltiples servicios raÃ­z
    const product = await this.productsService.create();
    await this.membersService.removeProduct();
    await this.globalProductSyncService.sync();
  }
}
```

---

### **âŒ ANTI-PATRONES (NUNCA HACER)**

#### **1. Dependencia Directa Entre Servicios RaÃ­z**

```typescript
// âŒ MAL: Servicio raÃ­z dependiendo de otro servicio raÃ­z
@Injectable()
export class ShipmentsService {
  constructor(
    private readonly officesService: OfficesService, // âŒ ACOPLAMIENTO
  ) {}

  async updateShipment() {
    // âŒ Llamada directa entre servicios raÃ­z
    await this.officesService.updateFlags();
  }
}
```

#### **2. LÃ³gica de CoordinaciÃ³n en Servicio RaÃ­z**

```typescript
// âŒ MAL: LÃ³gica de coordinaciÃ³n mezclada con CRUD
@Injectable()
export class ProductsService {
  constructor(
    private readonly membersService: MembersService, // âŒ ACOPLAMIENTO
    private readonly shipmentsService: ShipmentsService, // âŒ ACOPLAMIENTO
  ) {}

  async updateProduct() {
    // âŒ Responsabilidad mezclada
    await this.save(); // CRUD (correcto)
    await this.membersService.updateFlags(); // âŒ CoordinaciÃ³n (incorrecto)
    await this.shipmentsService.updateStatus(); // âŒ CoordinaciÃ³n (incorrecto)
  }
}
```

---

### **ğŸ”§ CÃ“MO REFACTORIZAR ACOPLAMIENTO**

#### **Paso 1: Identificar el Problema**

```typescript
// ğŸš¨ DETECTAR: Â¿Hay servicios raÃ­z inyectados en otros servicios raÃ­z?
class ServiceA {
  constructor(private serviceB: ServiceB) {} // ğŸš¨ PROBLEMA
}
```

#### **Paso 2: Crear Coordinador**

```typescript
// âœ… CREAR: Servicio transversal coordinador
@Injectable()
export class ServiceABCoordinatorService {
  constructor(
    private readonly serviceA: ServiceA,
    private readonly serviceB: ServiceB,
  ) {}

  async coordinateOperation() {
    await this.serviceA.doSomething();
    await this.serviceB.doSomethingElse();
  }
}
```

#### **Paso 3: Refactorizar Dependencias**

```typescript
// âœ… REFACTORIZAR: Usar coordinador en lugar de dependencia directa
class ServiceA {
  constructor(
    private readonly coordinator: ServiceABCoordinatorService, // âœ… CORRECTO
  ) {}

  async operation() {
    await this.coordinator.coordinateOperation();
  }
}
```

#### **Paso 4: Actualizar MÃ³dulos**

```typescript
// âœ… AGREGAR: Coordinador a mÃ³dulos relevantes
@Module({
  providers: [
    ServiceA,
    ServiceB,
    ServiceABCoordinatorService, // âœ… AGREGAR
  ],
})
export class SomeModule {}
```

---

### **ğŸ“‹ CHECKLIST DE VALIDACIÃ“N**

**Antes de crear/modificar servicios:**

- [ ] **Â¿Es un servicio raÃ­z?** â†’ Solo debe hacer CRUD de su entidad
- [ ] **Â¿Necesita otro servicio raÃ­z?** â†’ Crear coordinador transversal
- [ ] **Â¿Es lÃ³gica de coordinaciÃ³n?** â†’ Debe ir en servicio transversal
- [ ] **Â¿Hay dependencias circulares?** â†’ Usar coordinadores para romperlas

**Al revisar cÃ³digo existente:**

- [ ] **Â¿Servicios raÃ­z inyectan otros servicios raÃ­z?** â†’ Refactorizar con coordinador
- [ ] **Â¿LÃ³gica de negocio compleja en servicios raÃ­z?** â†’ Mover a transversal
- [ ] **Â¿MÃºltiples responsabilidades en un servicio?** â†’ Separar en coordinadores

---

### **ğŸ¯ EJEMPLOS REALES DEL PROYECTO**

#### **âœ… CORRECTO: ShipmentOfficeCoordinatorService**

```
ShipmentsService â†’ ShipmentOfficeCoordinatorService â†’ OfficesService
LogisticsService â†’ ShipmentOfficeCoordinatorService â†’ OfficesService
```

#### **âœ… CORRECTO: AssignmentsService**

```
Controller â†’ AssignmentsService â†’ ProductsService + MembersService + GlobalSync
```

#### **âœ… CORRECTO: LogisticsService**

```
Controller â†’ LogisticsService â†’ ShipmentsService + ProductsService + MembersService
```

#### **âŒ INCORRECTO (Ejemplo de lo que NO hacer)**

```
ShipmentsService â†’ OfficesService (ACOPLAMIENTO DIRECTO)
ProductsService â†’ MembersService (ACOPLAMIENTO DIRECTO)
```

#### **Servicios Comunes**

- **`CommonService`**: Utilidades compartidas
- **`ValidationService`**: Validaciones reutilizables
- **`InfraService`**: Servicios de infraestructura base

---

## ğŸ¢ Multi-Tenant Architecture

### **Estructura de Base de Datos**

- **Tenant Database**: `tenant_{tenantName}` (ej: `tenant_mechi_test`)
  - Collections: `products`, `members`, `shipments`, `offices`, `teams`, `historial`, `shipmentsMetadata`
- **Global Database**: `firstPlug`
  - Collections: `tenants`, `users`, `global_products`, `warehouses`

### **Roles y Permisos**

- **SuperAdmin**: Acceso a todos los tenants, puede crear/modificar cualquier dato
- **Tenant User**: Solo acceso a su tenant especÃ­fico
- **admin**: Solo acceso a su tenant especÃ­fico

### **Tenant Resolution**

```typescript
// Siempre resolver tenant por tenantName
const connection = await this.connectionService.getTenantConnection(tenantName);
const ProductModel = connection.model('Product', ProductSchema);
```

---

## ğŸ“¦ Ubicaciones de Productos

### **Ubicaciones VÃ¡lidas**

- **`"Employee"`**: Producto asignado a un member (en `members` collection)
- **`"FP warehouse"`**: Producto en warehouse de FirstPlug (en `products` collection)
- **`"Our office"`**: Producto en oficina del tenant (en `products` collection)

### **Collections por UbicaciÃ³n**

- **Employee** â†’ `members.products[]` (embebido)
- **FP warehouse** â†’ `products` collection + `fpWarehouse` data
- **Our office** â†’ `products` collection + `office` data

### **Multi-Office Support (CORE)**

#### **Estructura de Datos de Oficina**

```typescript
// Estructura del objeto office en productos
office: {
  officeId: ObjectId,           // ID de la oficina
  officeCountryCode: string,    // CÃ³digo de paÃ­s de la oficina
  officeName: string,           // Nombre de la oficina
  assignedAt: Date,            // Fecha de asignaciÃ³n
  isDefault: boolean           // Si es la oficina por defecto
}
```

#### **Reglas de AsignaciÃ³n de Oficina**

- âœ… **`officeId` requerido** cuando `location = "Our office"` en endpoints de usuarios
- âœ… **Oficina default automÃ¡tica** si no se especifica `officeId` para `location = "Our office"`
- âœ… **ValidaciÃ³n de existencia** de oficina antes de asignar
- âœ… **ConstrucciÃ³n automÃ¡tica** del objeto `office` completo usando `buildOfficeObject()`

#### **Reglas de ImplementaciÃ³n (CRÃTICAS)**

- âœ… **Solo cuando `location = "Our office"`** se debe incluir objeto `office`
- âœ… **Coexistencia obligatoria**: Si maneja `fpWarehouse` â†’ debe manejar `office`
- âœ… **Seguir patrÃ³n `fpWarehouse`** exactamente como referencia
- âœ… **Persistencia obligatoria** en movimientos con `fp_shipment`
- âœ… **Preservar datos existentes** en sincronizaciÃ³n global
- âŒ **NUNCA** agregar `office` a mÃ©todos que NO manejan `fpWarehouse`
- âŒ **NUNCA** hardcodear datos de oficina

#### **Endpoints que Soportan `officeId`**

| Endpoint                          | DTO                     | Soporte Multi-Office                |
| --------------------------------- | ----------------------- | ----------------------------------- |
| `POST /products`                  | `CreateProductDto`      | âœ… Individual                       |
| `POST /products/bulkcreate`       | `CreateProductArrayDto` | âœ… **Bulk con diferentes oficinas** |
| `PATCH /products/:id`             | `UpdateProductDto`      | âœ… Individual                       |
| `PATCH /products/reassign/:id`    | `UpdateProductDto`      | âœ… Individual                       |
| `POST /assignments/bulk-reassign` | `BulkReassignDto`       | âœ… **Bulk con diferentes oficinas** |

#### **ImplementaciÃ³n Obligatoria**

```typescript
// âœ… CORRECTO: Usar buildOfficeObject para construir datos completos
const officeData = await this.assignmentsService.buildOfficeObject(
  officeId,
  tenantName,
);

// âœ… CORRECTO: Aplicar a producto
const productData = {
  ...baseProduct,
  ...officeData, // Incluye objeto office completo
};
```

#### **PatrÃ³n de AsignaciÃ³n con Persistencia (CORE)**

```typescript
// ğŸ¢ OFFICE ASSIGNMENT: Seguir patrÃ³n fpWarehouse
if (updateDto.location === 'Our office' && updateDto.officeId) {
  const officeData = await this.buildOfficeObject(
    updateDto.officeId as string,
    tenantName,
  );

  if (officeData.office) {
    Object.assign(updatedProduct, { office: officeData.office });

    // ğŸ’¾ GUARDAR: Necesario para persistir campos
    await updatedProduct.save({ session });

    // ğŸ”„ SYNC: Forzar sincronizaciÃ³n global
    delete (updatedProduct as any)._alreadySyncedToGlobal;
    await this.syncProductToGlobal(updatedProduct, tenantName, 'products');
  }
}
```

#### **MÃ©todos que Requieren PatrÃ³n de AsignaciÃ³n**

**âœ… MÃ©todos que SÃ implementan el patrÃ³n (porque tambiÃ©n manejan `fpWarehouse`):**

- `handleProductFromMemberCollection` - Con persistencia y sync âœ…
- `assignProduct` - Con construcciÃ³n de office âœ…
- `moveToProductsCollection` - Con handleOfficeAssignment âœ…
- `handleUnknownEmailUpdate` - Con construcciÃ³n bÃ¡sica âœ…

**âŒ MÃ©todos que NO deben implementar el patrÃ³n (porque NO manejan `fpWarehouse`):**

- `updateProductAttributes` - Solo actualiza atributos del array
- `handleProductUnassignment` - Solo desasigna, no maneja objetos
- `handleProductFromProductsCollection` (caso normal) - Solo actualiza campos bÃ¡sicos

**âš ï¸ Regla de Oro: Coexistencia**

- **SI** un mÃ©todo maneja `fpWarehouse` â†’ **DEBE** manejar `office`
- **SI** un mÃ©todo NO maneja `fpWarehouse` â†’ **NO DEBE** manejar `office`
- **Mantener** la coexistencia perfecta entre ambos objetos

#### **âŒ Errores Comunes a Evitar**

1. **âŒ Agregar `office` a `updateProductAttributes`**

   - Este mÃ©todo solo actualiza el array `attributes`
   - NO maneja `fpWarehouse`, por tanto NO debe manejar `office`

2. **âŒ Agregar `office` a `handleProductUnassignment`**

   - Este mÃ©todo solo desasigna productos
   - NO maneja `fpWarehouse`, por tanto NO debe manejar `office`

3. **âŒ Romper la coexistencia**

   - Siempre verificar: "Â¿Este mÃ©todo maneja `fpWarehouse`?"
   - Si NO â†’ NO agregar `office`
   - Si SÃ â†’ SÃ agregar `office`

4. **âŒ Mantener `office` al mover a "Employee"**

   - Cuando un producto se mueve de "Our office" a "Employee", el objeto `office` DEBE eliminarse
   - Solo productos en `location: "Our office"` deben tener objeto `office`
   - Verificar que `handleOfficeAssignment` elimine `office` para locations â‰  "Our office"

5. **âŒ Preservar `office` incorrectamente en sync global**
   - Solo preservar `office` existente si la nueva location sigue siendo "Our office"
   - Si location cambiÃ³ a "Employee" o "FP warehouse", `office` debe ser `null`

---

## ï¿½ Estados de Productos (SAGRADO)

### **Regla Fundamental: Estado = f(Location, Shipment)**

#### **Sin Shipment Activo**

- **Location: `"Employee"`** â†’ Status: `"Delivered"`
- **Location: `"FP warehouse"`** â†’ Status: `"Available"`
- **Location: `"Our office"`** â†’ Status: `"Available"`

#### **Con Shipment Activo (SincronizaciÃ³n Obligatoria)**

| Shipment Status            | Product Status                |
| -------------------------- | ----------------------------- |
| `"On Hold - Missing Data"` | `"In Transit - Missing Data"` |
| `"In Preparation"`         | `"In Transit"`                |
| `"On The Way"`             | `"In Transit"`                |
| `"Received"`               | SegÃºn location final          |
| `"Cancelled"`              | SegÃºn location final          |

### **ImplementaciÃ³n Obligatoria**

```typescript
// SIEMPRE calcular status basado en shipment + location
const status = await this.productsService.determineProductStatus(
  {
    fp_shipment: product.fp_shipment,
    location: product.location,
    activeShipment: product.activeShipment,
  },
  tenantName,
);
```

---

## ï¿½ğŸ”„ Acciones de Movimiento de Productos

### **Acciones VÃ¡lidas**

- **`assign`**: Asignar producto disponible a member
- **`reassign`**: Cambiar asignaciÃ³n de producto (member â†’ warehouse/office, warehouse â†” office)
- **`return`**: Devolver producto de member a warehouse u office
- **`relocate`**: Mover producto desde member a otro member
- **`offboarding`**: Procesar productos de member que se va se pueden enviar a otro member, office o warehouse

### **Movimientos Warehouse â†” Office (NUEVO)**

#### **Funcionalidad Implementada**

- âœ… **FP warehouse â†’ Our office** usando `assign`/`reassign`
- âœ… **Our office â†’ FP warehouse** usando `assign`/`reassign`
- âœ… **Limpieza automÃ¡tica** de objetos de ubicaciÃ³n anterior
- âœ… **PreservaciÃ³n de `lastAssigned`** con formato correcto

#### **ImplementaciÃ³n TÃ©cnica**

```typescript
// ğŸ§¹ MÃ©todo de limpieza automÃ¡tica
private handleLocationObjectCleanup(
  newLocation: string | undefined,
  currentProduct: any,
): { fpWarehouse?: undefined; office?: undefined } {
  // Detecta movimientos y limpia objetos automÃ¡ticamente
  // - Warehouse â†’ Office: limpia fpWarehouse
  // - Office â†’ Warehouse: limpia office
  // - Warehouse/Office â†’ Employee: limpia ambos
}
```

#### **IntegraciÃ³n en MÃ©todos Clave**

- âœ… **`moveToProductsCollection()`** - Member â†’ Warehouse/Office
- âœ… **`moveToMemberCollection()`** - Warehouse/Office â†’ Member
- âœ… **`handleProductFromProductsCollection()`** - Warehouse â†” Office directo
- âŒ **`handleUnknownEmailUpdate()`** - NO aplica (ver secciÃ³n anterior)

#### **Casos de Uso**

```typescript
// âœ… Office â†’ Warehouse
{
  "location": "FP warehouse",
  "actionType": "reassign",
  "assignedEmail": "none",
  "status": "Available"
}

// âœ… Warehouse â†’ Office
{
  "location": "Our office",
  "actionType": "reassign",
  "assignedEmail": "none",
  "officeId": "office-id", // Opcional, usa default
  "status": "Available"
}
```

#### **PreservaciÃ³n de lastAssigned**

- **Warehouse â†’ Office**: `lastAssigned = "FP warehouse - AR - Warehouse Name"`
- **Office â†’ Warehouse**: `lastAssigned = "Our office - AR - Office Name"`
- **Formato automÃ¡tico** usando `LastAssignedHelper`

### **Requerimientos OBLIGATORIOS**

#### **1. Preservar `lastAssigned`**

```typescript
// SIEMPRE usar LastAssignedHelper para calcular lastAssigned
const calculatedLastAssigned =
  this.lastAssignedHelper.calculateForProductUpdate(
    product,
    newLocation,
    actionType,
  );
```

#### **2. SincronizaciÃ³n Global**

```typescript
// SIEMPRE sincronizar a global collection despuÃ©s de cambios
await this.globalProductSyncService.syncProduct({
  tenantId: tenantName,
  originalProductId: product._id,
  sourceCollection: 'products' | 'members',
  // ... otros campos
});
```

#### **3. Transacciones MongoDB**

```typescript
// SIEMPRE usar transacciones para operaciones crÃ­ticas
const session = await connection.startSession();
session.startTransaction();
try {
  // ... operaciones
  await session.commitTransaction();
} catch (error) {
  await session.abortTransaction();
  throw error;
} finally {
  session.endSession();
}
```

#### **4. Validaciones de Estado**

- **activeShipment**: No permitir cambios si producto tiene shipment activo
- **Warehouse assignment**: Asignar warehouse automÃ¡ticamente para `location: "FP warehouse"`
- **Member validation**: Verificar que member existe antes de asignar

#### **5. Evitar Duplicados**

- **Una sola sincronizaciÃ³n por flujo**: Usar flag `_alreadySyncedToGlobal`
- **Consistent IDs**: Usar mismo `_id` para `originalProductId` en global collection

---

## ğŸ“§ Productos con Emails Desconocidos (CRÃTICO)

### **Contexto: `handleUnknownEmailUpdate()`**

Este mÃ©todo maneja un caso especial muy importante que **NO debe confundirse** con movimientos warehouseâ†”office.

#### **Â¿QuÃ© son productos con emails desconocidos?**

- **Origen**: Productos subidos via CSV con `assignedEmail` que **no hace match** con ningÃºn member en la colecciÃ³n `members`
- **UbicaciÃ³n temporal**: Se almacenan en `products` collection porque **no hay member registrado** con ese email
- **Realidad conceptual**: Son productos de **"members fantasma"** - el email representa a un empleado real, pero ese empleado no estÃ¡ registrado en el sistema
- **UbicaciÃ³n lÃ³gica**: Conceptualmente son `"Employee"` (asignados a un member), pero temporalmente estÃ¡n en `products`

#### **Flujos posibles:**

1. **Se registra el member** â†’ El producto se mueve automÃ¡ticamente a `members.products[]`
2. **Se reasigna el producto** â†’ Desde "member fantasma" hacia warehouse, office, o member real

#### **âš ï¸ REGLA CRÃTICA: NO es movimiento warehouseâ†”office**

```typescript
// âŒ INCORRECTO: Agregar cleanup warehouseâ†”office aquÃ­
public async handleUnknownEmailUpdate() {
  // ...
  const cleanupFields = this.handleLocationObjectCleanup(); // âŒ NO APLICA
}

// âœ… CORRECTO: Solo manejar asignaciones normales
public async handleUnknownEmailUpdate() {
  // Warehouse assignment si se mueve a "FP warehouse"
  // Office assignment si se mueve a "Our office"
  // NO cleanup porque origen NUNCA es warehouse/office
}
```

#### **Â¿Por quÃ© NO aplica cleanup warehouseâ†”office?**

- **Origen siempre es "Employee"** (member fantasma)
- **Destino puede ser warehouse/office/employee**, pero **origen nunca es warehouse/office**
- **No hay objetos `fpWarehouse` o `office`** que limpiar porque el producto viene de un "member fantasma"

#### **Casos de uso reales:**

```typescript
// âœ… VÃLIDO: Member fantasma â†’ FP warehouse
{
  assignedEmail: "empleado.no.registrado@empresa.com", // No existe en members
  location: "FP warehouse",
  actionType: "reassign"
}

// âœ… VÃLIDO: Member fantasma â†’ Our office
{
  assignedEmail: "empleado.no.registrado@empresa.com", // No existe en members
  location: "Our office",
  actionType: "reassign",
  officeId: "office-id"
}

// âœ… VÃLIDO: Member fantasma â†’ Member real
{
  assignedEmail: "empleado.registrado@empresa.com", // Existe en members
  location: "Employee",
  actionType: "reassign"
}
```

#### **ğŸš¨ Regla de Oro para Modificaciones**

**ANTES** de modificar `handleUnknownEmailUpdate()`:

1. **Preguntarse**: Â¿El producto viene de warehouse o office?
2. **Respuesta**: **NO** - siempre viene de "member fantasma"
3. **ConclusiÃ³n**: **NO** agregar cleanup warehouseâ†”office
4. **AcciÃ³n**: Solo manejar asignaciones hacia destino final

#### **MÃ©todos donde SÃ aplica cleanup warehouseâ†”office:**

- âœ… `moveToProductsCollection()` - Member real â†’ Warehouse/Office
- âœ… `moveToMemberCollection()` - Warehouse/Office â†’ Member real
- âœ… `handleProductFromProductsCollection()` - Warehouse â†” Office directo

#### **MÃ©todos donde NO aplica cleanup:**

- âŒ `handleUnknownEmailUpdate()` - Member fantasma â†’ Cualquier destino
- âŒ `updateProductAttributes()` - Solo actualiza atributos
- âŒ `handleProductUnassignment()` - Solo desasigna

---

## ğŸ› ï¸ Reglas de Desarrollo

### **GestiÃ³n de Dependencias**

- âœ… **SIEMPRE** usar package managers: `npm install`, `yarn add`, etc.
- âŒ **NUNCA** editar manualmente: `package.json`, `requirements.txt`, etc.

### **EdiciÃ³n de Archivos**

- âœ… **Archivos existentes**: Usar `str-replace-editor`
- âœ… **Archivos nuevos**: Usar `save-file`
- âŒ **NUNCA** sobrescribir archivos existentes con `save-file`

### **Validaciones**

- âœ… **Nuevos endpoints**: Usar Zod schemas
- âœ… **DTOs**: Convertir de class-validator a Zod cuando sea necesario
- âœ… **ValidaciÃ³n condicional**: `name` requerido solo para category "Merchandising"
- âœ… **Serial Number**: Opcional pero Ãºnico por tenant (cuando se proporciona)
- âœ… **Bulk operations**: Validar duplicados solo en serial numbers no-null

### **Validaciones de Seguridad (CRÃTICAS)**

#### **1. RestricciÃ³n de "FP warehouse" para usuarios regulares**

- âœ… **Backend validation**: Usuarios regulares NO pueden crear productos inicialmente en "FP warehouse"
- âœ… **Permitir movimientos**: Usuarios SÃ pueden mover productos a "FP warehouse" via return/reassign/offboarding
- âœ… **SuperAdmin exception**: SuperAdmin SÃ puede crear productos en "FP warehouse"
- âœ… **ActionType detection**: Usar presencia de `actionType` para distinguir creaciÃ³n vs movimiento

```typescript
// âœ… CORRECTO: ValidaciÃ³n en Zod schema
.refine(
  (data) => {
    // Solo bloquear si es creaciÃ³n inicial (sin actionType) y usuario regular
    return !(data.location === 'FP warehouse' && !data.actionType);
  },
  { message: 'Regular users cannot create products in FP warehouse' }
)

// âœ… CORRECTO: ValidaciÃ³n en service
if (createDto.location === 'FP warehouse' && !isSuperAdmin) {
  throw new BadRequestException('Regular users cannot create products in FP warehouse');
}
```

#### **2. ValidaciÃ³n de oficinas con shipments activos**

- âœ… **Bloqueo de ediciÃ³n**: Oficinas con shipments "On The Way" no pueden editarse
- âœ… **Frontend support**: Endpoint GET /offices incluye `hasOnTheWayShipments` para deshabilitar UI
- âœ… **Mensaje claro**: Error descriptivo cuando se intenta editar oficina bloqueada

```typescript
// âœ… CORRECTO: Datos enviados al frontend
{
  "_id": "...",
  "name": "Oficina Principal",
  "hasOnTheWayShipments": true,  // â† Frontend usa esto para deshabilitar ediciÃ³n
  "hasActiveShipments": true,
  "hasAssignedProducts": true
}
```

### **Logging y Debugging**

- âœ… **Logs estructurados**: Incluir contexto (tenantName, productId, etc.)
- âœ… **Prefijos claros**: `[ServiceName]`, `ğŸ”„`, `âœ…`, `âŒ`
- âœ… **Debug logs**: Para troubleshooting de bugs complejos
- âœ… **Logs temporales**: Agregar para debugging, remover despuÃ©s de fix
- âœ… **Logs de validaciÃ³n**: Para identificar quÃ© validaciÃ³n especÃ­fica falla

#### **PatrÃ³n de Debugging Efectivo**

```typescript
// âœ… CORRECTO: Logs temporales para debugging
console.log('ğŸ” [METHOD_NAME] Datos antes de operaciÃ³n:', {
  productId: product._id,
  location: product.location,
  hasOffice: !!product.office,
  officeData: product.office,
});

// DespuÃ©s de identificar y corregir el problema:
// âŒ REMOVER: Los logs temporales de debugging
```

#### **Logs de ValidaciÃ³n para 400 Errors**

```typescript
// âœ… CORRECTO: Logs para identificar validaciones que fallan
console.log('ğŸ” [UPDATE_OFFICE] Verificando shipments "On The Way"...');
const hasOnTheWayShipments = await this.hasOnTheWayShipments(id, tenantName);
console.log('ğŸ” [UPDATE_OFFICE] hasOnTheWayShipments:', hasOnTheWayShipments);

if (hasOnTheWayShipments) {
  console.log('âŒ [UPDATE_OFFICE] Bloqueado por shipments "On The Way"');
  throw new BadRequestException('...');
}
```

---

## ğŸ› Bugs Conocidos y Soluciones

### **1. Acoplamiento de Servicios (CRÃTICO)**

**Causa**: Inyectar servicios raÃ­z en otros servicios raÃ­z
**SÃ­ntomas**:

- Dependencias circulares
- CÃ³digo difÃ­cil de testear
- ViolaciÃ³n de responsabilidad Ãºnica
  **SoluciÃ³n**: Crear servicio coordinador transversal
  **Ejemplo**: `ShipmentOfficeCoordinatorService` para `ShipmentsService` â†” `OfficesService`

### **2. Duplicados en Global Collection**

**Causa**: MÃºltiples sincronizaciones del mismo producto
**SoluciÃ³n**: Flag `_alreadySyncedToGlobal` + skip resync para reassign/return

### **3. lastAssigned VacÃ­o**

**Causa**: No preservar ubicaciÃ³n anterior al mover productos
**SoluciÃ³n**: Usar `LastAssignedHelper.calculateForProductUpdate()`

### **4. originalProductId null**

**Causa**: Sincronizar antes de que el producto tenga `_id`
**SoluciÃ³n**: Sincronizar DESPUÃ‰S de `member.save()`

### **5. CSV con FP warehouse**

**Causa**: Templates viejos permiten ubicaciÃ³n no vÃ¡lida
**SoluciÃ³n**: ValidaciÃ³n Zod que rechaza arrays con `location: "FP warehouse"`

### **6. Eventos Innecesarios**

**Causa**: Usar eventos complejos para coordinaciÃ³n simple
**SÃ­ntomas**:

- Listeners complejos
- CÃ³digo difÃ­cil de seguir
- Debugging complicado
  **SoluciÃ³n**: Llamadas directas a travÃ©s de coordinadores

### **7. SerialNumber duplicado con strings vacÃ­as**

**Causa**: SuperAdmin methods no normalizaban `serialNumber`, guardando `""` en lugar de `undefined`
**SÃ­ntomas**: Error `E11000 duplicate key error` al crear productos con `serialNumber: ""`
**SoluciÃ³n**: NormalizaciÃ³n obligatoria `serialNumber?.trim() || undefined` en todos los mÃ©todos

```typescript
// âœ… CORRECTO: NormalizaciÃ³n en todos los mÃ©todos
const normalizedSerialNumber = serialNumber?.trim() || undefined;

// âœ… APLICAR EN: create, bulkCreate, createProductForTenant, bulkCreateProductsForTenant
```

### **8. Objeto office no eliminado al asignar a Employee**

**Causa**: `handleOfficeAssignment` preservaba `office` para cualquier location con office existente
**SÃ­ntomas**: Productos en "Employee" mantenÃ­an objeto `office` de ubicaciÃ³n anterior
**SoluciÃ³n**: Solo preservar `office` si `location === 'Our office'`

```typescript
// âœ… CORRECTO: EliminaciÃ³n condicional de office
if (location === 'Our office' && currentOffice) {
  return { office: currentOffice };
}
// Para cualquier otra location, no incluir office
return {};
```

---

## ğŸ“‹ Checklist para Nuevas Features

### **Antes de Implementar**

- [ ] **ğŸ—ï¸ ARQUITECTURA**: Â¿Respeta el patrÃ³n de servicios por capas?
- [ ] **ğŸš¨ ACOPLAMIENTO**: Â¿Evita dependencias directas entre servicios raÃ­z?
- [ ] **ğŸ”„ COORDINACIÃ“N**: Â¿Necesita coordinador transversal?
- [ ] **ModularizaciÃ³n**: Â¿Encaja en carpeta/servicio existente?
- [ ] **Servicios**: Identificar raÃ­z vs transversales involucrados
- [ ] **TenantModelRegistry**: Â¿Requiere nuevos modelos por tenant?
- [ ] **Transacciones**: Â¿Operaciones crÃ­ticas que requieren atomicidad?
- [ ] **SincronizaciÃ³n**: Planificar sync a global collection
- [ ] **Estados**: Considerar impacto en status de productos/shipments
- [ ] **lastAssigned**: Evaluar cambios en ubicaciones

### **Durante ImplementaciÃ³n**

- [ ] **ğŸ—ï¸ SERVICIOS**: Â¿Es servicio raÃ­z o transversal?
- [ ] **ğŸš¨ INYECCIÃ“N**: Â¿Solo inyecta servicios de su capa o inferiores?
- [ ] **ğŸ”„ COORDINADORES**: Â¿Usa coordinadores para comunicaciÃ³n entre servicios raÃ­z?
- [ ] **Dependencias**: Usar package managers (npm, yarn)
- [ ] **Validaciones**: Implementar schemas Zod
- [ ] **Logs**: Agregar logs estructurados con contexto
- [ ] **Errores**: Manejar excepciones apropiadamente
- [ ] **Estados**: Respetar reglas SAGRADAS de status
- [ ] **Modularidad**: Seguir patrÃ³n de servicios establecido

### **DespuÃ©s de Implementar**

- [ ] **ğŸ—ï¸ ARQUITECTURA**: Â¿Respeta todas las reglas de servicios por capas?
- [ ] **ğŸš¨ ACOPLAMIENTO**: Â¿No hay dependencias directas entre servicios raÃ­z?
- [ ] **ğŸ”„ COORDINACIÃ“N**: Â¿Los coordinadores funcionan correctamente?
- [ ] **Movimientos**: Probar flujos de productos (assign/reassign/return)
- [ ] **SincronizaciÃ³n**: Verificar sync a global collection
- [ ] **Duplicados**: Confirmar que no hay duplicados
- [ ] **Estados**: Validar status correcto segÃºn shipment/location
- [ ] **lastAssigned**: Verificar preservaciÃ³n de ubicaciones
- [ ] **Transacciones**: Confirmar atomicidad de operaciones crÃ­ticas

---

## ğŸ¯ Principios Clave

1. **ModularizaciÃ³n**: Reutilizar servicios existentes antes de crear nuevos
2. **Estados SAGRADOS**: Status de productos SIEMPRE sincronizado con shipments
3. **Consistencia**: Mismo patrÃ³n para operaciones similares
4. **Transaccionalidad**: Operaciones atÃ³micas para integridad de datos
5. **Observabilidad**: Logs claros para debugging
6. **Escalabilidad**: Servicios desacoplados y reutilizables
7. **Confiabilidad**: Validaciones exhaustivas y manejo de errores
8. **TenantModelRegistry**: GestiÃ³n centralizada de modelos multi-tenant

---

## ğŸš¨ Reglas SAGRADAS (NUNCA ROMPER)

### **1. Arquitectura de Servicios (CRÃTICO)**

- âœ… **Servicios raÃ­z** NUNCA dependen de otros servicios raÃ­z
- âœ… **Usar coordinadores** para comunicaciÃ³n entre servicios raÃ­z
- âœ… **Responsabilidad Ãºnica** por servicio
- âŒ **PROHIBIDO**: `ShipmentsService` â†’ `OfficesService` (directo)
- âœ… **CORRECTO**: `ShipmentsService` â†’ `Coordinator` â†’ `OfficesService`

### **2. Estados de Productos**

- âœ… **Sin shipment + Employee** = `"Delivered"`
- âœ… **Sin shipment + Warehouse/Office** = `"Available"`
- âœ… **Con shipment** = Status sincronizado con shipment status

### **3. SincronizaciÃ³n Global**

- âœ… **Siempre** sincronizar cambios a `global_products`
- âœ… **Una sola** sincronizaciÃ³n por flujo (evitar duplicados)
- âœ… **Consistent IDs** entre collections locales y global
- âœ… **PreservaciÃ³n automÃ¡tica** de objetos `fpWarehouse`, `office`, `memberData`
- âœ… **PatrÃ³n de preservaciÃ³n**: Si no viene nuevo valor, preservar existente
- âœ… **Forzar sync**: `delete product._alreadySyncedToGlobal` antes de sincronizar
- âœ… **Timing crÃ­tico**: Sincronizar DESPUÃ‰S de crear shipment y actualizar status
- âœ… **Status consistency**: Global collection debe reflejar status final del producto

```typescript
// âœ… CORRECTO: SincronizaciÃ³n despuÃ©s de shipment
// 1. Crear/actualizar producto
// 2. Crear shipment (si fp_shipment: true)
// 3. Actualizar status del producto
// 4. ENTONCES sincronizar a global
await this.syncProductToGlobal(updatedProduct, tenantName, sourceCollection);
```

### **4. Transacciones**

- âœ… **Operaciones crÃ­ticas** SIEMPRE en transacciones
- âœ… **Rollback** automÃ¡tico en caso de error
- âœ… **Atomicidad** para movimientos de productos

### **5. lastAssigned**

- âœ… **Preservar** ubicaciÃ³n anterior al mover productos
- âœ… **Usar** `LastAssignedHelper` para cÃ¡lculos
- âœ… **Formato** correcto: email para Employee, "FP warehouse - {country}" para warehouse

### **6. CoordinaciÃ³n de Servicios**

- âœ… **Crear coordinador** cuando se necesite comunicaciÃ³n entre servicios raÃ­z
- âœ… **Inyectar coordinador** en servicios que lo necesiten
- âœ… **Documentar** nuevos coordinadores en este archivo
- âŒ **PROHIBIDO**: Eventos complejos para coordinaciÃ³n simple
- âŒ **PROHIBIDO**: LÃ³gica de coordinaciÃ³n en servicios raÃ­z

### **7. Multi-Office Support**

- âœ… **`officeId` obligatorio** para `location = "Our office"` en endpoints de usuarios
- âœ… **Usar `buildOfficeObject()`** para construir datos completos de oficina
- âœ… **Soporte bulk operations** con diferentes oficinas por producto
- âœ… **Oficina default automÃ¡tica** si no se especifica `officeId`
- âŒ **PROHIBIDO**: Asignar productos a oficinas inexistentes
- âŒ **PROHIBIDO**: Omitir validaciÃ³n de existencia de oficina
