# Augment Agent - Configuración del Proyecto FirstPlug

## 🏗️ Arquitectura del Sistema

### **Patrón de Servicios por Capas**

#### **Servicios Raíz (Root Services)**

Interactúan directamente con la base de datos, manejan CRUD básico:

- **`ProductsService`**: Gestión de productos en collections locales
- **`MembersService`**: Gestión de members y productos embebidos
- **`ShipmentsService`**: Gestión de shipments y logistics
- **`TenantsService`**: Gestión de tenants y configuración
- **`WarehousesService`**: Gestión de warehouses y asignaciones

#### **Servicios Transversales (Cross-cutting Services)**

Coordinan entre servicios raíz, manejan lógica de negocio compleja:

- **`AssignmentsService`**: Movimiento de productos entre collections
- **`LogisticsService`**: Coordinación de shipments y actualizaciones
- **`GlobalProductSyncService`**: Sincronización a collection global
- **`WarehouseAssignmentService`**: Asignación inteligente de warehouses
- **`ShipmentOfficeCoordinatorService`**: Coordinación entre shipments y oficinas

#### **Servicios Helper**

Lógica de negocio específica y reutilizable:

- **`LastAssignedHelper`**: Cálculo de lastAssigned preservando ubicaciones
- **`SlackService`**: Notificaciones y alertas
- **`HistoryService`**: Tracking de cambios y auditoría

#### **Servicios de Infraestructura**

- **`SuperAdminService`**: Operaciones cross-tenant, gestión global
- **`AuthService`**: Autenticación y autorización
- **`ConfigService`**: Configuración de aplicación
- **`TenantModelRegistry`**: Registry de modelos por tenant (CLAVE)
- **`TenantConnectionService`**: Gestión de conexiones multi-tenant

#### **🚨 PATRÓN DE COORDINACIÓN (REGLA SAGRADA)**

**REGLA FUNDAMENTAL**: Los servicios raíz NUNCA deben depender directamente de otros servicios raíz.

**PROBLEMA COMÚN**: Inyectar un servicio raíz en otro servicio raíz crea acoplamiento fuerte.

**SOLUCIÓN OBLIGATORIA**: Crear servicios transversales coordinadores.

---

### **📊 Diagrama de Arquitectura Correcta**

```
SERVICIOS RAÍZ (Root Services)
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│ ProductsService │    │ MembersService  │    │ ShipmentsService│
│                 │    │                 │    │                 │
│ - CRUD productos│    │ - CRUD members  │    │ - CRUD shipments│
│ - Solo DB ops   │    │ - Solo DB ops   │    │ - Solo DB ops   │
└─────────────────┘    └─────────────────┘    └─────────────────┘

┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│ TenantsService  │    │WarehousesService│    │ OfficesService  │
│                 │    │                 │    │                 │
│ - CRUD tenants  │    │ - CRUD warehouse│    │ - CRUD offices  │
│ - Solo DB ops   │    │ - Solo DB ops   │    │ - Solo DB ops   │
└─────────────────┘    └─────────────────┘    └─────────────────┘

                              ▲
                              │
                    NO DEPENDENCIES ENTRE ELLOS
                              │
                              ▼

SERVICIOS TRANSVERSALES (Cross-cutting Services)
┌─────────────────────────────────────────────────────────────────┐
│                    COORDINADORES                                │
├─────────────────────────────────────────────────────────────────┤
│ AssignmentsService          │ LogisticsService                  │
│ - Coordina Products+Members │ - Coordina Shipments+Products     │
│                             │                                   │
│ GlobalProductSyncService    │ ShipmentOfficeCoordinatorService  │
│ - Coordina sync global      │ - Coordina Shipments+Offices      │
└─────────────────────────────────────────────────────────────────┘
```

---

### **✅ PATRONES CORRECTOS**

#### **1. Coordinador Simple**

```typescript
// ✅ CORRECTO: Servicio transversal coordina entre servicios raíz
@Injectable()
export class ShipmentOfficeCoordinatorService {
  constructor(private readonly officesService: OfficesService) {}

  async handleShipmentStatusChange(
    originOfficeId: Types.ObjectId | null,
    destinationOfficeId: Types.ObjectId | null,
    oldStatus: string,
    newStatus: string,
    tenantName: string,
  ): Promise<void> {
    // Lógica de coordinación
    await this.officesService.updateActiveShipmentsFlagsForShipment(
      originOfficeId,
      destinationOfficeId,
      tenantName,
    );
  }
}

// ✅ CORRECTO: Servicio raíz usa coordinador
@Injectable()
export class ShipmentsService {
  constructor(private readonly coordinator: ShipmentOfficeCoordinatorService) {}

  async updateShipment() {
    // ... lógica de shipment

    // Delegar coordinación al servicio transversal
    await this.coordinator.handleShipmentStatusChange(
      originOfficeId,
      destinationOfficeId,
      oldStatus,
      newStatus,
      tenantName,
    );
  }
}
```

#### **2. Coordinador Complejo (Múltiples Servicios)**

```typescript
// ✅ CORRECTO: Coordinador que maneja múltiples servicios raíz
@Injectable()
export class AssignmentsService {
  constructor(
    private readonly productsService: ProductsService,
    private readonly membersService: MembersService,
    private readonly globalProductSyncService: GlobalProductSyncService,
  ) {}

  async moveProductFromMemberToWarehouse() {
    // Coordina entre múltiples servicios raíz
    const product = await this.productsService.create();
    await this.membersService.removeProduct();
    await this.globalProductSyncService.sync();
  }
}
```

---

### **❌ ANTI-PATRONES (NUNCA HACER)**

#### **1. Dependencia Directa Entre Servicios Raíz**

```typescript
// ❌ MAL: Servicio raíz dependiendo de otro servicio raíz
@Injectable()
export class ShipmentsService {
  constructor(
    private readonly officesService: OfficesService, // ❌ ACOPLAMIENTO
  ) {}

  async updateShipment() {
    // ❌ Llamada directa entre servicios raíz
    await this.officesService.updateFlags();
  }
}
```

#### **2. Lógica de Coordinación en Servicio Raíz**

```typescript
// ❌ MAL: Lógica de coordinación mezclada con CRUD
@Injectable()
export class ProductsService {
  constructor(
    private readonly membersService: MembersService, // ❌ ACOPLAMIENTO
    private readonly shipmentsService: ShipmentsService, // ❌ ACOPLAMIENTO
  ) {}

  async updateProduct() {
    // ❌ Responsabilidad mezclada
    await this.save(); // CRUD (correcto)
    await this.membersService.updateFlags(); // ❌ Coordinación (incorrecto)
    await this.shipmentsService.updateStatus(); // ❌ Coordinación (incorrecto)
  }
}
```

---

### **🔧 CÓMO REFACTORIZAR ACOPLAMIENTO**

#### **Paso 1: Identificar el Problema**

```typescript
// 🚨 DETECTAR: ¿Hay servicios raíz inyectados en otros servicios raíz?
class ServiceA {
  constructor(private serviceB: ServiceB) {} // 🚨 PROBLEMA
}
```

#### **Paso 2: Crear Coordinador**

```typescript
// ✅ CREAR: Servicio transversal coordinador
@Injectable()
export class ServiceABCoordinatorService {
  constructor(
    private readonly serviceA: ServiceA,
    private readonly serviceB: ServiceB,
  ) {}

  async coordinateOperation() {
    await this.serviceA.doSomething();
    await this.serviceB.doSomethingElse();
  }
}
```

#### **Paso 3: Refactorizar Dependencias**

```typescript
// ✅ REFACTORIZAR: Usar coordinador en lugar de dependencia directa
class ServiceA {
  constructor(
    private readonly coordinator: ServiceABCoordinatorService, // ✅ CORRECTO
  ) {}

  async operation() {
    await this.coordinator.coordinateOperation();
  }
}
```

#### **Paso 4: Actualizar Módulos**

```typescript
// ✅ AGREGAR: Coordinador a módulos relevantes
@Module({
  providers: [
    ServiceA,
    ServiceB,
    ServiceABCoordinatorService, // ✅ AGREGAR
  ],
})
export class SomeModule {}
```

---

### **📋 CHECKLIST DE VALIDACIÓN**

**Antes de crear/modificar servicios:**

- [ ] **¿Es un servicio raíz?** → Solo debe hacer CRUD de su entidad
- [ ] **¿Necesita otro servicio raíz?** → Crear coordinador transversal
- [ ] **¿Es lógica de coordinación?** → Debe ir en servicio transversal
- [ ] **¿Hay dependencias circulares?** → Usar coordinadores para romperlas

**Al revisar código existente:**

- [ ] **¿Servicios raíz inyectan otros servicios raíz?** → Refactorizar con coordinador
- [ ] **¿Lógica de negocio compleja en servicios raíz?** → Mover a transversal
- [ ] **¿Múltiples responsabilidades en un servicio?** → Separar en coordinadores

---

### **🎯 EJEMPLOS REALES DEL PROYECTO**

#### **✅ CORRECTO: ShipmentOfficeCoordinatorService**

```
ShipmentsService → ShipmentOfficeCoordinatorService → OfficesService
LogisticsService → ShipmentOfficeCoordinatorService → OfficesService
```

#### **✅ CORRECTO: AssignmentsService**

```
Controller → AssignmentsService → ProductsService + MembersService + GlobalSync
```

#### **✅ CORRECTO: LogisticsService**

```
Controller → LogisticsService → ShipmentsService + ProductsService + MembersService
```

#### **❌ INCORRECTO (Ejemplo de lo que NO hacer)**

```
ShipmentsService → OfficesService (ACOPLAMIENTO DIRECTO)
ProductsService → MembersService (ACOPLAMIENTO DIRECTO)
```

#### **Servicios Comunes**

- **`CommonService`**: Utilidades compartidas
- **`ValidationService`**: Validaciones reutilizables
- **`InfraService`**: Servicios de infraestructura base

---

## 🏢 Multi-Tenant Architecture

### **Estructura de Base de Datos**

- **Tenant Database**: `tenant_{tenantName}` (ej: `tenant_mechi_test`)
  - Collections: `products`, `members`, `shipments`, `offices`, `teams`, `historial`, `shipmentsMetadata`
- **Global Database**: `firstPlug`
  - Collections: `tenants`, `users`, `global_products`, `warehouses`

### **Roles y Permisos**

- **SuperAdmin**: Acceso a todos los tenants, puede crear/modificar cualquier dato
- **Tenant User**: Solo acceso a su tenant específico
- **admin**: Solo acceso a su tenant específico

### **Tenant Resolution**

```typescript
// Siempre resolver tenant por tenantName
const connection = await this.connectionService.getTenantConnection(tenantName);
const ProductModel = connection.model('Product', ProductSchema);
```

---

## 📦 Ubicaciones de Productos

### **Ubicaciones Válidas**

- **`"Employee"`**: Producto asignado a un member (en `members` collection)
- **`"FP warehouse"`**: Producto en warehouse de FirstPlug (en `products` collection)
- **`"Our office"`**: Producto en oficina del tenant (en `products` collection)

### **Collections por Ubicación**

- **Employee** → `members.products[]` (embebido)
- **FP warehouse** → `products` collection + `fpWarehouse` data
- **Our office** → `products` collection + office data

---

## � Estados de Productos (SAGRADO)

### **Regla Fundamental: Estado = f(Location, Shipment)**

#### **Sin Shipment Activo**

- **Location: `"Employee"`** → Status: `"Delivered"`
- **Location: `"FP warehouse"`** → Status: `"Available"`
- **Location: `"Our office"`** → Status: `"Available"`

#### **Con Shipment Activo (Sincronización Obligatoria)**

| Shipment Status            | Product Status                |
| -------------------------- | ----------------------------- |
| `"On Hold - Missing Data"` | `"In Transit - Missing Data"` |
| `"In Preparation"`         | `"In Transit"`                |
| `"On The Way"`             | `"In Transit"`                |
| `"Received"`               | Según location final          |
| `"Cancelled"`              | Según location final          |

### **Implementación Obligatoria**

```typescript
// SIEMPRE calcular status basado en shipment + location
const status = await this.productsService.determineProductStatus(
  {
    fp_shipment: product.fp_shipment,
    location: product.location,
    activeShipment: product.activeShipment,
  },
  tenantName,
);
```

---

## �🔄 Acciones de Movimiento de Productos

### **Acciones Válidas**

- **`assign`**: Asignar producto disponible a member
- **`reassign`**: Cambiar asignación de producto (member → warehouse/office)
- **`return`**: Devolver producto de member a warehouse u office
- **`relocate`**: Mover producto desde member a otro member
- **`offboarding`**: Procesar productos de member que se va se pueden enviar a otro member, office o warehouse

### **Requerimientos OBLIGATORIOS**

#### **1. Preservar `lastAssigned`**

```typescript
// SIEMPRE usar LastAssignedHelper para calcular lastAssigned
const calculatedLastAssigned =
  this.lastAssignedHelper.calculateForProductUpdate(
    product,
    newLocation,
    actionType,
  );
```

#### **2. Sincronización Global**

```typescript
// SIEMPRE sincronizar a global collection después de cambios
await this.globalProductSyncService.syncProduct({
  tenantId: tenantName,
  originalProductId: product._id,
  sourceCollection: 'products' | 'members',
  // ... otros campos
});
```

#### **3. Transacciones MongoDB**

```typescript
// SIEMPRE usar transacciones para operaciones críticas
const session = await connection.startSession();
session.startTransaction();
try {
  // ... operaciones
  await session.commitTransaction();
} catch (error) {
  await session.abortTransaction();
  throw error;
} finally {
  session.endSession();
}
```

#### **4. Validaciones de Estado**

- **activeShipment**: No permitir cambios si producto tiene shipment activo
- **Warehouse assignment**: Asignar warehouse automáticamente para `location: "FP warehouse"`
- **Member validation**: Verificar que member existe antes de asignar

#### **5. Evitar Duplicados**

- **Una sola sincronización por flujo**: Usar flag `_alreadySyncedToGlobal`
- **Consistent IDs**: Usar mismo `_id` para `originalProductId` en global collection

---

## 🛠️ Reglas de Desarrollo

### **Gestión de Dependencias**

- ✅ **SIEMPRE** usar package managers: `npm install`, `yarn add`, etc.
- ❌ **NUNCA** editar manualmente: `package.json`, `requirements.txt`, etc.

### **Edición de Archivos**

- ✅ **Archivos existentes**: Usar `str-replace-editor`
- ✅ **Archivos nuevos**: Usar `save-file`
- ❌ **NUNCA** sobrescribir archivos existentes con `save-file`

### **Validaciones**

- ✅ **Nuevos endpoints**: Usar Zod schemas
- ✅ **DTOs**: Convertir de class-validator a Zod cuando sea necesario
- ✅ **Validación condicional**: `name` requerido solo para category "Merchandising"

### **Logging y Debugging**

- ✅ **Logs estructurados**: Incluir contexto (tenantName, productId, etc.)
- ✅ **Prefijos claros**: `[ServiceName]`, `🔄`, `✅`, `❌`
- ✅ **Debug logs**: Para troubleshooting de bugs complejos

---

## 🐛 Bugs Conocidos y Soluciones

### **1. Acoplamiento de Servicios (CRÍTICO)**

**Causa**: Inyectar servicios raíz en otros servicios raíz
**Síntomas**:

- Dependencias circulares
- Código difícil de testear
- Violación de responsabilidad única
  **Solución**: Crear servicio coordinador transversal
  **Ejemplo**: `ShipmentOfficeCoordinatorService` para `ShipmentsService` ↔ `OfficesService`

### **2. Duplicados en Global Collection**

**Causa**: Múltiples sincronizaciones del mismo producto
**Solución**: Flag `_alreadySyncedToGlobal` + skip resync para reassign/return

### **3. lastAssigned Vacío**

**Causa**: No preservar ubicación anterior al mover productos
**Solución**: Usar `LastAssignedHelper.calculateForProductUpdate()`

### **4. originalProductId null**

**Causa**: Sincronizar antes de que el producto tenga `_id`
**Solución**: Sincronizar DESPUÉS de `member.save()`

### **5. CSV con FP warehouse**

**Causa**: Templates viejos permiten ubicación no válida
**Solución**: Validación Zod que rechaza arrays con `location: "FP warehouse"`

### **6. Eventos Innecesarios**

**Causa**: Usar eventos complejos para coordinación simple
**Síntomas**:

- Listeners complejos
- Código difícil de seguir
- Debugging complicado
  **Solución**: Llamadas directas a través de coordinadores

---

## 📋 Checklist para Nuevas Features

### **Antes de Implementar**

- [ ] **🏗️ ARQUITECTURA**: ¿Respeta el patrón de servicios por capas?
- [ ] **🚨 ACOPLAMIENTO**: ¿Evita dependencias directas entre servicios raíz?
- [ ] **🔄 COORDINACIÓN**: ¿Necesita coordinador transversal?
- [ ] **Modularización**: ¿Encaja en carpeta/servicio existente?
- [ ] **Servicios**: Identificar raíz vs transversales involucrados
- [ ] **TenantModelRegistry**: ¿Requiere nuevos modelos por tenant?
- [ ] **Transacciones**: ¿Operaciones críticas que requieren atomicidad?
- [ ] **Sincronización**: Planificar sync a global collection
- [ ] **Estados**: Considerar impacto en status de productos/shipments
- [ ] **lastAssigned**: Evaluar cambios en ubicaciones

### **Durante Implementación**

- [ ] **🏗️ SERVICIOS**: ¿Es servicio raíz o transversal?
- [ ] **🚨 INYECCIÓN**: ¿Solo inyecta servicios de su capa o inferiores?
- [ ] **🔄 COORDINADORES**: ¿Usa coordinadores para comunicación entre servicios raíz?
- [ ] **Dependencias**: Usar package managers (npm, yarn)
- [ ] **Validaciones**: Implementar schemas Zod
- [ ] **Logs**: Agregar logs estructurados con contexto
- [ ] **Errores**: Manejar excepciones apropiadamente
- [ ] **Estados**: Respetar reglas SAGRADAS de status
- [ ] **Modularidad**: Seguir patrón de servicios establecido

### **Después de Implementar**

- [ ] **🏗️ ARQUITECTURA**: ¿Respeta todas las reglas de servicios por capas?
- [ ] **🚨 ACOPLAMIENTO**: ¿No hay dependencias directas entre servicios raíz?
- [ ] **🔄 COORDINACIÓN**: ¿Los coordinadores funcionan correctamente?
- [ ] **Movimientos**: Probar flujos de productos (assign/reassign/return)
- [ ] **Sincronización**: Verificar sync a global collection
- [ ] **Duplicados**: Confirmar que no hay duplicados
- [ ] **Estados**: Validar status correcto según shipment/location
- [ ] **lastAssigned**: Verificar preservación de ubicaciones
- [ ] **Transacciones**: Confirmar atomicidad de operaciones críticas

---

## 🎯 Principios Clave

1. **Modularización**: Reutilizar servicios existentes antes de crear nuevos
2. **Estados SAGRADOS**: Status de productos SIEMPRE sincronizado con shipments
3. **Consistencia**: Mismo patrón para operaciones similares
4. **Transaccionalidad**: Operaciones atómicas para integridad de datos
5. **Observabilidad**: Logs claros para debugging
6. **Escalabilidad**: Servicios desacoplados y reutilizables
7. **Confiabilidad**: Validaciones exhaustivas y manejo de errores
8. **TenantModelRegistry**: Gestión centralizada de modelos multi-tenant

---

## 🚨 Reglas SAGRADAS (NUNCA ROMPER)

### **1. Arquitectura de Servicios (CRÍTICO)**

- ✅ **Servicios raíz** NUNCA dependen de otros servicios raíz
- ✅ **Usar coordinadores** para comunicación entre servicios raíz
- ✅ **Responsabilidad única** por servicio
- ❌ **PROHIBIDO**: `ShipmentsService` → `OfficesService` (directo)
- ✅ **CORRECTO**: `ShipmentsService` → `Coordinator` → `OfficesService`

### **2. Estados de Productos**

- ✅ **Sin shipment + Employee** = `"Delivered"`
- ✅ **Sin shipment + Warehouse/Office** = `"Available"`
- ✅ **Con shipment** = Status sincronizado con shipment status

### **3. Sincronización Global**

- ✅ **Siempre** sincronizar cambios a `global_products`
- ✅ **Una sola** sincronización por flujo (evitar duplicados)
- ✅ **Consistent IDs** entre collections locales y global

### **4. Transacciones**

- ✅ **Operaciones críticas** SIEMPRE en transacciones
- ✅ **Rollback** automático en caso de error
- ✅ **Atomicidad** para movimientos de productos

### **5. lastAssigned**

- ✅ **Preservar** ubicación anterior al mover productos
- ✅ **Usar** `LastAssignedHelper` para cálculos
- ✅ **Formato** correcto: email para Employee, "FP warehouse - {country}" para warehouse

### **6. Coordinación de Servicios**

- ✅ **Crear coordinador** cuando se necesite comunicación entre servicios raíz
- ✅ **Inyectar coordinador** en servicios que lo necesiten
- ✅ **Documentar** nuevos coordinadores en este archivo
- ❌ **PROHIBIDO**: Eventos complejos para coordinación simple
- ❌ **PROHIBIDO**: Lógica de coordinación en servicios raíz
